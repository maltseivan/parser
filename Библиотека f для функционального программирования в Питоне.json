[
   "Библиотека f для функционального программирования в Питоне",
   "Привет, коллеги!\nЯ расскажу о библиотеке для Питона с лаконичным названием f. Это небольшой пакет с функциями и классами для решения задач в функциональном стиле.\n — Что, еще одна функциональная либа для Питона? Автор, ты в курсе, что есть fn.py и вообще этих функциональных поделок миллион?\n — Да, в курсе.\nПричины появления библиотеки\nЯ занимаюсь Питоном довольно давно, но пару лет назад всерьез увлекся функциональным программированием и Кложей в частности. Некоторые подходы, принятые в ФП, произвели на меня столь сильное впечатление, что мне захотелось перенести их в повседневную разработку.\nПодчеркну, что не приемлю подход, когда паттерны одного языка грубо внедряют в другой без учета его принципов и соглашений о кодировании. Как бы я не любил ФП, меня раздражает нагромождение мап и лямбд в попытке выдать это за функциональный стиль.\nПоэтому я старался оформить мои функции так, чтобы не встретить сопротивление коллег. Например, использовать внутри стандартные циклы с условиями вместо мапов и редьюсов, чтобы облегчить понимание тем, кто не знаком с ФП.\nВ результате некоторые из частей библиотеки побывали в боевых проектах и, возможно, все еще в строю. Сперва я копипастил их из проекта в проект, потом завел файлик-свалку функций и сниппетов, и, наконец, оформил все библиотекой, пакетом в Pypi и документаций.\nОбщие сведения\nБиблиотека написана на чистом Питоне и работает на любой ОС, в т.ч. на Виндузе. Поддерживаются обе ветки Питона. Конкретно я проверял на версиях 2.6, 2.7 и 3.5. Если возникнут трудности с другими версиями, дайте знать. Единственная зависимость — пакет six для гибкой разработки сразу под обе ветки.\nБиблиотека ставится стандартным образом через pip:\npip install f\nВсе функции и классы доступны в головном модуле. Это значит, не нужно запоминать\r\nпути к сущностям:\nimport f\n\nf.pcall(...)\nf.maybe(...)\nf.io_wraps(...)\nf.L[1, 2, 3]\nПакет несет на борту следующие подсистемы:\n\nнабор различных функций для удобной работы с данными\nмодуль предикатов для быстрой проверки на какие-либо условия\nулучшенные версии коллекций — списка, кортежа, словаря и множества\nреализация дженерика\nмонады Maybe, Either, IO, Error\n\nВ разделах ниже я приведу примеры кода с комментариями.\nФункции\nПервой функцией, которую я перенес в Питон из другой экосистемы, стала pcall из языка Луа. Я программировал на ней несколько лет назад, и хотя язык не функциональный, был от него в восторге.\nФункция pcall (protected call, защищенный вызов) принимает другую функцию и возвращает пару (err, result), где либо err — ошибка и result пуст, либо наоборот. Этот подход знаком нам по другим языкам, например, Джаваскрипту или Гоу.\nimport f\n\nf.pcall(lambda a, b: a / b, 4, 2)\n>>> (None, 2)\n\nf.pcall(lambda a, b: a / b, 4, 0)\n>>> (ZeroDivisionError('integer division or modulo by zero'), None)\nФункцию удобно использовать как декоратор к уже написанным функциям, которые кидают исключения:\n\n@f.pcall_wraps\ndef func(a, b):\n    return a / b\n\nfunc(4, 2)\n>>> (None, 2)\n\nfunc(4, 0)\n>>> (ZeroDivisionError('integer division or modulo by zero'), None)\nИспользуя деструктивный синтаксис, можно распаковать результат на уровне сигнатуры:\n\ndef process((err, result)):\n    if err:\n        logger.exception(err)\n        return 0\n\n    return result + 42\n\nprocess(func(4, 2))\nК большому сожалению, деструктивный синтаксис выпилен в третьем Питоне. Приходится распаковывать вручную.\nИнтерсно, что использование пары (err, result) есть ни что иное, как монада Either, о которой мы еще поговорим.\nВот более реалистичный пример pcall. Часто приходится делать ХТТП-запросы и получать структуры данных из джейсона. Во время запроса может произойти масса ошибок:\n\nкривые хосты, ошибка резолва\nтаймаут соединения\nсервер вернул 500\nсервер вернул 200, но парсинг джейсона упал\nсервер вернул 200, но в ответе ошибка\n\nЗаворачивать вызов в try с отловом четырех исключений означает сделать код абсолютно нечитаемым. Рано или поздно вы забудете что-то перехватить, и программа упадет. Вот пример почти реального кода. Он извлекает пользователя из локального рест-сервиса. Результат всегда будет парой:\n@f.pcall_wraps\ndef get_user(use_id):\n    resp = requests.get(\"http://local.auth.server\",\n                        params={\"id\": user_id}, timeout=3)\n\n    if not resp.ok:\n        raise IOError(\"<log HTTP code and body here>\")\n\n    data = resp.json()\n\n    if \"error\" in data:\n        raise BusinesException(\"<log here data>\")\n\n    return data\nРассмотрим другие функции библиотеки. Мне бы хотелось выделить f.achain и f.ichain. Обе предназначены для безопасного извлечения данных из объектов по цепочке.\nПредположим, у вас Джанго со следующими моделями:\nOrder => Office => Department => Chief\nПри этом все поля not null и вы без страха ходите по смежным полям:\norder = Order.objects.get(id=42)\nboss_name = order.office.department.chief.name\nДа, я в курсе про select_related, но это роли не играет. Ситуация справедлива не только для ОРМ, но и для любой другой структуры класов.\nТак было в нашем проекте, пока один заказчик не попросил сделать некоторые ссылки пустыми, потому что таковы особенности его бизнеса. Мы сделали поля в базе nullable и были рады, что легко отделались. Конечно, из-за спешки мы не написали юнит-тесты для моделей с пустыми ссылками, а в старых тестах модели были заполнены правильно. Клиент начал работать с обновленными моделями и получил ошибки.\nФункция f.achain безопасно проходит по цепочке атрибутов:\nf.achain(model, 'office', 'department', 'chief', 'name')\n>>> John\nЕсли цепочка нарушена (поле равно None, не существуте), результат будет None.\nФункция-аналог f.ichain пробегает по цепочке индексов. Она работает со словарями, списками и кортежами. Функция удобна для работы с данными, полученными из джейсона:\ndata = json.loads('''{\"result\": [{\"kids\": [{\"age\": 7, \"name\": \"Leo\"},\n                     {\"age\": 1, \"name\": \"Ann\"}], \"name\": \"Ivan\"},\n                     {\"kids\": null, \"name\": \"Juan\"}]}''')\n\nf.ichain(data, 'result', 0, 'kids', 0, 'age')\n>>> 7\n\nf.ichain(data, 'result', 0, 'kids', 42, 'dunno')\n>> None\nОбе функции я забрал из Кложи, где их предок называется get-in. Удобство в том, что в микросерверной архитектуре структура ответа постоянно меняется и может не соответствовать здравому смыслу.\nНапример, в ответе есть поле-объект \"user\" с вложенными полями. Однако, если пользователя по какой-то причине нет, поле будет не пустым объектом, а None. В коде начнут возникать уродливые конструкции типа:\ndata.get('user', {]}).get('address', {}).get('street', '<unknown>')\nНаш вариант читается легче:\nf.ichain(data, 'user', 'address', 'street') or '<unknown>'\nИз Кложи в библиотеку f перешли два threading-макроса: -> и ->>. В библиотеке они называются f.arr1 и f.arr2. Оба пропускают исходное значение сквозь функиональные формы. Этот термин в Лиспе означает выражение, которе вычисляется позже.\nДругими словами, форма — это либо функция func, либо кортеж вида (func, arg1, arg2, ...). Такую форму можно передать куда-то как замороженное выражение и вычислить позже с изменениями. Получается что-то вроде макросов в Лиспе, только очень убого.\nf.arr1 подставляет значение (и дальнейший результат) в качестве первого\r\nаргумента формы:\nf.arr1(\n    -42,                        # начальное значение\n    (lambda a, b: a + b, 2),    # форма\n    abs,                        # форма\n    str,                        # форма\n)\n>>> \"40\"\nf.arr2 делает то же самое, но ставит значение в конец формы:\nf.arr2(\n    -2,\n    abs,\n    (lambda a, b: a + b, 2),\n    str,\n    (\"000\".replace, \"0\")\n)\n>>> \"444\"\nДалее, функция f.comp возвращает композицию функций:\ncomp = f.comp(abs, (lambda x: x * 2), str)\ncomp(-42)\n>>> \"84\"\nf.every_pred строит супер-предикат. Это такой предикат, который истиннен только если все внутренние предикаты истинны.\npred1 = f.p_gt(0)        # строго положительный\npred2 = f.p_even         # четный\npred3 = f.p_not_eq(666)  # не равный 666\n\nevery = f.every_pred(pred1, pred2, pred3)\n\nresult = filter(every, (-1, 1, -2, 2, 3, 4, 666, -3, 1, 2))\ntuple(result)\n>>> (2, 4, 2)\nСупер-предикат ленив: он обрывает цепочку вычислений на первом же ложном значении. В примере выше использованы предикаты из модуля predicate.py, о котором мы еще поговорим.\nФункция f.transduce — наивная попытка реализовать паттерн transducer (преобразователь) из Кложи. Короткими словами, transducer — это комбинация функций map и reduce. Их суперпозиция дает преобразование по принципу \"из чего угодно во что угодно без промежуточных данных\":\nf.transduce(\n    (lambda x: x + 1),\n    (lambda res, item: res + str(item)),\n    (1, 2, 3),\n    \"\"\n)\n>>> \"234\"\nМодуль функций замыкет f.nth и его синонимы: f.first, f.second и f.third для безопасного обращения к элементам коллекций:\nf.first((1, 2, 3))\n>>> 1\n\nf.second((1, 2, 3))\n>>> 2\n\nf.third((1, 2, 3))\n>>> 3\n\nf.nth(0, [1, 2, 3])\n>>> 1\n\nf.nth(9, [1, 2, 3])\n>>> None\nПредикаты\nПредикат — это выражение, возвращающие истину или ложь. Предикаты используют в математике, логике и функциональном программировании. Часто предикат передают в качестве переменной в функции высшего порядка.\nЯ добавил несколько наиболее нужных предикатов в библиотеку. Предикаты могут унарными (без параметров) и бинарными (или параметрическими), когда поведение предиката зависит от первого аргумента.\nРассмотрим примеры с унарными предикатами:\nf.p_str(\"test\")\n>>> True\n\nf.p_str(0)\n>>> False\n\nf.p_str(u\"test\")\n>>> True\n\n# особый предикат, который проверяет на int и float одновременно\nf.p_num(1), f.p_num(1.0)\n>>> True, True\n\nf.p_list([])\n>>> True\n\nf.p_truth(1)\n>>> True\n\nf.p_truth(None)\n>>> False\n\nf.p_none(None)\n>>> True\nТеперь бинарные. Создадим новый предикат, который утверждает, что что-то больше нуля. Что именно? Пока неизвесто, это абстракция.\np = f.p_gt(0)\nТеперь, имея предикат, проверим любое значение:\np(1), p(100), p(0), p(-1)\n>>> True, True, False, False\nПо аналогии:\n# Что-то больше или равно нуля:\np = f.p_gte(0)\np(0), p(1), p(-1)\n>>> True, True, False\n\n# Проверка на точное равенство:\np = f.p_eq(42)\np(42), p(False)\n>>> True, False\n\n# Проверка на ссылочное равенство:\nob1 = object()\np = f.p_is(ob1)\n\np(object())\n>>> False\n\np(ob1)\n>>> True\n\n# Проверка на вхождение в известную коллекцию:\np = f.p_in((1, 2, 3))\n\np(1), p(3)\n>>> True, True\n\np(4)\n>>> False\nЯ не буду приводить примеры всех предикатов, это утомительно и долго. Предикаты прекрасно работают с функциями композиции f.comp, супер-предиката f.every_pred, встроенной функцией filter и дженериком, о котором речь ниже.\nДженерики\nДженерик (общий, обобщенный) — вызываемый объект, который имеет несколько стратегий вычисления результата. Выбор стратегии определяется на основании входящий параметров: их состава, типа или значения. Дженерик допускает наличие стратегии по умолчанию, когда не найдено ни одной другой для переданных параметров.\nВ Питоне нет дженериков из коробки, и особо они не нужны. Питон достаточно гибок, чтобы построить свою систему подбора функции под входящие значения. И все же, мне настолько понравилась реализация дженериков в Коммон-Лиспе, что из спортивного интереса я решил сделать что-то подобное в своей библиотеке.\nВыглядит это примерно так. Сначала создадим экземпляр дженерика:\ngen = f.Generic()\nТеперь расширим его конкретными обработчиками. Декоратор .extend принимает набор предикатов для этого обработчика, по одному на аргумент.\n@gen.extend(f.p_int, f.p_str)\ndef handler1(x, y):\n    return str(x) + y\n\n@gen.extend(f.p_int, f.p_int)\ndef handler2(x, y):\n    return x + y\n\n@gen.extend(f.p_str, f.p_str)\ndef handler3(x, y):\n    return x + y + x + y\n\n@gen.extend(f.p_str)\ndef handler4(x):\n    return \"-\".join(reversed(x))\n\n@gen.extend()\ndef handler5():\n    return 42\n\nЛогика под капотом проста: декоратор подшивает функцию во внутренний словарь вместе с назначенными ей предикатами. Теперь дженерик можно вызывать с произвольными аргументами. При вызове ищется функция с таким же количеством предикаторв. Если каждый предикат возвращает истину для соответствующего аргумента, считается, что стратегия найдена. Возвращается результат вызова найденной функции:\n\ngen(1, \"2\")\n>>> \"12\"\n\ngen(1, 2)\n>>> 3\n\ngen(\"fiz\", \"baz\")\n>>> \"fizbazfizbaz\"\n\ngen(\"hello\")\n>>> \"o-l-l-e-h\"\n\ngen()\n>>> 42\nЧто случится, если не подошла ни одна стратегия? Зависит от того, был ли задан обработчик по умолчанию. Такой обработчик должен быть готов встретить произвольное число аргументов:\ngen(1, 2, 3, 4)\n>>> TypeError exception goes here...\n\n@gen.default\ndef default_handler(*args):\n    return \"default\"\n\ngen(1, 2, 3, 4)\n>>> \"default\"\nПосле декорирования функция становится экземпляром дженерика. Интересный прием — вы можете перебрасывать исполнение одной стратегии в другую. Получаются функции с несколькими телами, почти как в Кложе, Эрланге или Хаскеле.\nОбработчик ниже будет вызван, если передать None. Однако, внутри он перенаправляет нас на другой обработчик с двумя интами, это handler2. Который, в свою очередь, возвращает сумму аргументов:\n@gen.extend(f.p_none)\ndef handler6(x):\n    return gen(1, 2)\n\ngen(None)\n>>> 3\nКоллекции\nБиблиотека предоставляет \"улучшенные\" коллекции, основанные на списке, кортеже, словаре и множестве. Под улучшениями я имею в виду дополнительные методы и некоторые особенности в поведении каждой из коллекций.\nУлучшенные коллекции создаются или из обычных вызовом класса, или особым синтаксисом с квадратными скобками:\nf.L[1, 2, 3]            # или f.List([1, 2, 3])\n>>> List[1, 2, 3]\n\nf.T[1, 2, 3]            # или f.Tuple([1, 2, 3])\n>>> Tuple(1, 2, 3)\n\nf.S[1, 2, 3]            # или f.Set((1, 2, 3))\n>>> Set{1, 2, 3}\n\nf.D[1: 2, 2: 3]\n>>> Dict{1: 2, 2: 3}    # или f.Dict({1: 2, 2: 3})\nКоллекции имеют методы .join, .foreach, .map, .filter, .reduce, .sum.\nСписок и кортеж дополнительно реализуют .reversed, .sorted, .group, .distinct и .apply.\nМетоды позволяют получить результат вызовом его из коллекции без передачи в функцию:\nl1 = f.L[1, 2, 3]\nl1.map(str).join(\"-\")\n>>> \"1-2-3\"\nresult = []\n\ndef collect(x, delta=0):\n    result.append(x + delta)\n\nl1.foreach(collect, delta=1)\nresult == [2, 3, 4]\n>>> True\nl1.group(2)\n>>> List[List[1, 2], List[3]]\nНе буду утомлять листингом на каждый метод, желающие могут посмотреть исходный код с комментариями.\nВажно, что методы возвращают новый экземпляр той же коллекции. Это уменьшает вероятность ее случайного измнения. Операция .map или любая другая на списке вернет список, на кортеже — кортеж и так далее:\nf.L[1, 2, 3].filter(f.p_even)\n>>> List[2]\nf.S[1, 2, 3].filter(f.p_even)\n>>> Set{2}\nСловарь итерируется по парам (ключ, значение), о чем я всегда мечтал:\nf.D[1: 1, 2: 2, 0: 2].filter(lambda (k, v): k + v == 2)\n>>> Dict{0: 2, 1: 1}\nУлучшенные коллекции можно складывать с любой другой коллекцией. Результатом станет новая коллекция этого (левого) типа:\n# Слияние словарей\nf.D(a=1, b=2, c=3) + {\"d\": 4, \"e\": 5, \"f\": 5}\n>>> Dict{'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'f': 5}\n\n# Множество + стандартный спосок\nf.S[1, 2, 3] + [\"a\", 1, \"b\", 3, \"c\"]\n>>> Set{'a', 1, 2, 3, 'c', 'b'}\n\n# Список и обычный кортеж\nf.L[1, 2, 3] + (4, )\nList[1, 2, 3, 4]\nЛюбую коллекцию можно переключить в другую:\nf.L[\"a\", 1, \"b\", 2].group(2).D()\n>>> Dict{\"a\": 1, \"b\": 2}\n\nf.L[1, 2, 3, 3, 2, 1].S().T()\n>>> Tuple[1, 2, 3]\nКомбо!\nf.L(\"abc\").map(ord).map(str).reversed().join(\"-\")\n>>> \"99-98-97\"\ndef pred(pair):\n    k, v = pair\n    return k == \"1\" and v == \"2\"\n\nf.L[4, 3, 2, 1].map(str).reversed() \\\n               .group(2).Dict().filter(pred)\n\n>>> Dict{\"1\": \"2\"}\nМонады\nПоследний и самый сложный раздел в библиотеке. Почитав цикл статей о монадах, я отважился добавить в библиотеку их тоже. При этом позволил себе следующие отклонения:\n\nПроверки входных значений основаны не на типах, как в Хаскеле, а на предикатах, что делает монады гибче.\n\nОператор >>= в Хаскеле невозможно перенести в Питон, поэтому он фигурирует как >> (он же __rshift__, битовый сдвиг вправо). Проблема в том, что в Хаскеле тоже есть оператор >>, но используется он реже, чем >>=. В итоге, в Питоне под >> мы понимаем >>= из Хаскела, а оригинальный >> просто не используем.\n\nНе смотря на усилия, я не смог реализовать do-нотацию Хаскелла из-за ограничений синтаксиса в Питоне. Пробовал и цикл, и генератор, и контекстные менеджеры — все мимо.\n\nMaybe\nМонада Maybe (возможно) так же известна как Option. Этот класс монад представлен двумя экземплярами: Just (или Some) — хранилище положительного результата, в которм мы заинтересованы. Nothing (в других языках — None) — пустой результат.\nПростой пример. Определим монадный конструктор — объект, который будет преобразовывать скалярные (плоские) значения в монадические:\nMaybeInt = f.maybe(f.p_int)\nПо-другому это называется unit, или монадная единица. Теперь получим монадные значения:\nMaybeInt(2)\n>>> Just[2]\n\nMaybeInt(\"not an int\")\n>>> Nothing\nВидим, что хорошим результатом будет только то, что проходит проверку на инт. Теперь попробуем в деле монадный конвеер (monadic pipeline):\nMaybeInt(2) >> (lambda x: MaybeInt(x + 2))\n>>> Just[4]\n\nMaybeInt(2) >> (lambda x: f.Nothing()) >> (lambda x: MaybeInt(x + 2))\n>>> Nothing\nИз примера видно, что Nothing прерывает исполнения цепочки. Если быть совсем точным, цепочка не обрывается, а проходит до конца, только на каждом шаге возвращается Nothing.\nЛюбую функцию можно накрыть монадным декоратором, чтобы получать из нее монадические представления скаляров. В примере ниже декоратор следит за тем, чтобы успехом считался только возрат инта — это значение пойдет в Just, все остальное — в Nothing:\n@f.maybe_wraps(f.p_num)\ndef mdiv(a, b):\n    if b:\n        return a / b\n    else:\n        return None\n\nmdiv(4, 2)\n>>> Just[2]\n\nmdiv(4, 0)\n>>> Nothing\nОператор >> по другому называется монадным связыванием или конвеером (monadic binding) и вызывается методом .bind:\nMaybeInt(2).bind(lambda x: MaybeInt(x + 1))\n>>> Just[3]\nОба способа >> и .bind могут принять не только функцию, но и функциональную форму, о которой я уже писал выше:\nMaybeInt(6) >> (mdiv, 2)\n>>> Just[3]\n\nMaybeInt(6).bind(mdiv, 2)\n>>> Just[3]\nЧтобы высвободить скалярное значение из монады, используйте метод .get. Важно помнить, что он не входит в классическое определение монад и является своего рода поблажкой. Метод .get должен быть строго на конце конвеера:\nm = MaybeInt(2) >> (lambda x: MaybeInt(x + 2))\nm.get()\n>>> 3\nEither\nЭта монада расширяет предыдущую. Проблема Maybe в том, что негативный результат отбрасывается, в то время как мы всегда хотим знать причину. Either состоит из подтипов Left и Right, левое и правое значения. Левое значение отвечает за негативный случай, а правое — за позитивный.\nПравило легко запомнить по фразе \"наше дело правое (то есть верное)\". Слово right в английском языке так же значит \"верный\".\nА вот и флешбек из прошлого: согласитесь, напоминает пару (err, result) из начала статьи? Коллбеки в Джаваскрипте? Результаты вызовов в Гоу (только в другом порядке)?\nТо-то же. Все это монады, только не оформленные в контейнеры и без математического аппарата.\nМонада Either используется в основном для отлова ошибок. Ошибочное значение уходит влево и становится результатом конвеера. Корректный результат пробрысывается вправо к следующим вычислениям.\nМонадический конструктор Either принимает два предиката: для левого значения и для правого. В примере ниже строковые значения пойдут в левое значение, числовые — в правое.\nEitherStrNum = f.either(f.p_str, f.p_num)\n\nEitherStrNum(\"error\")\n>>> Left[error]\n\nEitherStrNum(42)\n>>> Right[42]\nПроверим конвеер:\nEitherStrNum(1) >> (lambda x: EitherStrNum(x + 1))\n>>> Right[2]\n\nEitherStrNum(1) >> (lambda x: EitherStrNum(\"error\")) \\\n                >> (lambda x: EitherStrNum(x + 1))\n>>> Left[error]\nДекоратор f.either_wraps делает из функции монадный конструктор:\n@f.either_wraps(f.p_str, f.p_num)\ndef ediv(a, b):\n    if b == 0:\n        return \"Div by zero: %s / %s\" % (a, b)\n    else:\n        return a / b\n\n@f.either_wraps(f.p_str, f.p_num)\ndef esqrt(a):\n    if a < 0:\n        return \"Negative number: %s\" % a\n    else:\n        return math.sqrt(a)\n\nEitherStrNum(16) >> (ediv, 4) >> esqrt\n>>> Right[2.0]\n\nEitherStrNum(16) >> (ediv, 0) >> esqrt\n>>> Left[Div by zero: 16 / 0]\nIO\nМонада IO (ввод-вывод) изолирует ввод-вывод данных, например, чтение файла, ввод с клавиатуры, печать на экран. Например, нам нужно спросить имя пользователя. Без монады мы бы просто вызвали raw_input, однако это снижает абстракцию и засоряет код побочным эффектом.\nВот как можно изолировать ввод с клавиатуры:\nIoPrompt = f.io(lambda prompt: raw_input(prompt))\nIoPrompt(\"Your name: \")      # Спросит имя. Я ввел \"Ivan\" и нажал RET\n>>> IO[Ivan]\nПоскольку мы получили монаду, ее можно пробросить дальше по конвееру. В примере ниже мы введем имя, а затем выведем его на экран. Декоратор f.io_wraps превращает функцию в монадический конструктор:\nimport sys\n\n@f.io_wraps\ndef input(msg):\n    return raw_input(msg)\n\n@f.io_wraps\ndef write(text, chan):\n    chan.write(text)\n\ninput(\"name: \") >> (write, sys.stdout)\n>>> name: Ivan   # ввод имени\n>>> Ivan         # печать имени\n>>> IO[None]     # результат\nError\nМонада Error, она же Try (Ошибка, Попытка) крайне полезна с практической точки зрения. Она изолирует исключения, гарантируя, что результатом вычисления станет либо экземпляр Success с правильным значением внутри, либо Failture с зашитым исключением.\nКак и в случае с Maybe и Either, монадный конвеер исполняется только для положительного результата.\nМонадический конструктор принимает функцию, поведение которой считается небезопасным. Дальнейшие вызовы дают либо Success, либо Failture:\nError = f.error(lambda a, b: a / b)\n\nError(4, 2)\n>>> Success[2]\n\nError(4, 0)\n>>> Failture[integer division or modulo by zero]\nВызов метода .get у экземпляра Failture повторно вызовет исключение. Как же до него добраться? Поможет метод .recover:\nError(4, 0).get()\nZeroDivisionError: integer division or modulo by zero\n\n# value variant\nError(4, 0).recover(ZeroDivisionError, 42)\nSuccess[2]\nЭтот метод принимает класс исключения (или кортеж классов), а так же новое значение. Результатом становится монада Success с переданным значением внутри. Значение может быть и функцией. Тогда в нее передается экземпляр исключения, а результат тоже уходит в Success. В этом месте появляется шанс залогировать исключение:\n\ndef handler(e):\n    logger.exception(e)\n    return 0\n\nError(4, 0).recover((ZeroDivisionError, TypeError), handler)\n>>> Success[0]\nВариант с декоратором. Функции деления и извлечения корня небезопасны:\n@f.error_wraps\ndef tdiv(a, b):\n    return a / b\n\n@f.error_wraps\ndef tsqrt(a):\n    return math.sqrt(a)\n\ntdiv(16, 4) >> tsqrt\n>>> Success[2.0]\n\ntsqrt(16).bind(tdiv, 2)\n>>> Success[2.0]\nКонвеер с расширенным контекстом\nХорошо, когда функции из конвеера требуют данные только из предыдущей монады. А что делать, если нужно значение, полученное два шага назад? Где хранить контекст?\nВ Хаскеле это проблему решает та самая do-нотация, которую не удалось повторить в Питоне. Придется воспользоваться вложенными функциями:\n\ndef mfunc1(a):\n    return f.Just(a)\n\ndef mfunc2(a):\n    return f.Just(a + 1)\n\ndef mfunc3(a, b):\n    return f.Just(a + b)\n\nmfunc1(1) >> (lambda x: mfunc2(x) >> (lambda y: mfunc3(x, y)))\n#                    1                       2         1  2\n>>> Just[3]\nВ примере выше затруднения в том, что функции mfunc3 нужно сразу два значения, полученных из других монад. Сохранить контекст пересенных x и y удается благодаря замыканиям. После выхода из замыкания цепочку можно продолжить дальше.\nЗаключение\nИтак, мы рассмотрели возможности библиотеки f. Напомню, проект не ставит цель вытеснить другие пакеты с функциональным уклоном. Это всего лишь попытка обобщить разрозненную практику автора, желание попробовать себя в роли мейнтейнера проекта с открытым исходным кодом. А еще — привлечь интерес начинающих разработчиков к функциональному подходу.\nСсылка на Гитхаб. Документация и тесты — там же. Пакет в Pypi.\nЯ надеюсь, специалисты по ФП простят неточности в формулировках.\nБуду рад замечаниям в комментариях. Спасибо за внимание. "
]