[
   "[Окончание] Новогодний детектив: странный хайзенбаг в «питоньих» часах",
   "\nЗдесь лежит окончание \"расследования\" Новогодний детектив: странный хайзенбаг в «питоньих» часах.\r\nИзначально хотел просто обновить статью и написать соответствующий комментарий, но понял что апдейт выходит чуть не длиннее самой статьи.\nНапомню краткое содержание предыдущей части: python, как впрочем и всё на нем написанное, временами прыгает в будущее, а конкретно в 2023-й год в локальной временной зоне, и по некоторым данным в 2024-й в UTC/GMT (но это не точно) и побыв там некоторое время возвращается обратно в настоящее.\nВо время прыжка оно ведет себя довольно стабильно (т.е. считает нано-, микро- и миллисекунды, а то и секунды, как будто время идет как ни в чём не бывало) в 2023-м т.е. локально, при том что в результате повторных прыжков время вновь продолжается как будто по возвращению оно (время) течет в какой-то параллельной вселенной. Однако странное его \"отражение\" в UTC/GMT, ну то что как будто бы в 2024-м, выглядит менее стабильно, ибо для него наблюдается странные дрейфы дополнительно к смещению прыжка.\nХотя куда уж страннее.\nВсё это в результате хоть и выглядит как \"битая память\", вряд ли этим объясняется, ибо во время аномалий наблюдаются совершенно ненормальные величины промежуточных значений unix time, для которых во главу угла можно положить преобразование вида:\nRT, UTC/GMT     ==>  t, UTC/GMT   ==>   lt, UTC-08:00\nCLOCK_REALTIME  ==>   time(RT)    ==>   localtime(t)\n---------------------------------------------------------------\n         1640M  ==>     1705M     ==>   1674M\nЧто как бы ни в целочисленной форме ни в формате с плавающей запятой простейшими битовыми операциями (& или |) не объяснить… Ну и как вишенка этот до странности стабильный результат для lt, при этом еще и \"корректно\" тикающий в течении временных аномалий.\n\"Расследование\" затянулось чуть-чуть — праздники, ну и человек, у которого оно поломано, никуда не торопится по всей видимости занятой очень, т.к. отвечает с паузами в два-три дня.\nСразу скажу что python был полностью неувиноватым… Во-первых, выяснилось, что ваабще неувиновный он. Ваабще чистой воды неувиновный. Крайней степени неувиновный. \nА если серьёзно, кто бы сомневался, однако лучше всё же по порядку...\nИтак, что еще делалось на той машине чтобы поймать багу (для тех кто не видел апдейты первой части):\n\nпереустановка Debian 11 а затем и Fedora 34 на той же VM с последующим тестом на чистых системах ничего не поменяла\npython 3.10.2 собранный из исходников показывает там тот же результат, аномалия воспроизводится с той же частотой и практически тем же дампом из под ltrace\nчеловек обращался с этим к хостеру — они ничего конкретного пока не ответили\n\nПоскольку с ltrace дальнейшее продвижение не видится возможным, а товарищ уже сам собирал питон из исходников, захотелось мне \"подебажить\" его немного на предмет уточнить в котором месте конкретно то всё ломается, т.е. запустить тест на дебажном и несколько пропатченом python.\nЧтобы не пугать человека gdb, conditional breakpoint и тому подобными конструкциями да из под консоли, на коленке была написана простенькая заплатка для python 3.10.2, с целью вывести некоторые промежуточные состояния и переменные в каждой функции в цепочке от clock_gettime до собственно местами кривого ответа time.time() и как он затем долетает до time.localtime():\n\npatch-debug-time.diff\ndiff --git a/Modules/timemodule.c b/Modules/timemodule.c\nindex 4caacc3b64..c975928fe7 100644\n--- a/Modules/timemodule.c\n+++ b/Modules/timemodule.c\n@@ -70,7 +70,9 @@ static PyObject*\n _PyFloat_FromPyTime(_PyTime_t t)\n {\n     double d = _PyTime_AsSecondsDouble(t);\n-    return PyFloat_FromDouble(d);\n+    PyObject* op = PyFloat_FromDouble(d);\n+    printf(\"**** %-40s%.3lf  ooo>>  %.3lf (O:%p)\\n\", __FUNCTION__, d, PyFloat_AsDouble(op), op);\n+    return op;\n }\n\n@@ -468,6 +470,7 @@ parse_time_t_args(PyObject *args, const char *format, time_t *pwhen)\n     else {\n         if (_PyTime_ObjectToTime_t(ot, &whent, _PyTime_ROUND_FLOOR) == -1)\n             return 0;\n+        printf(\"**** %-40s%.ld....  <<ooo  %.3lf (O:%p)\\n\", __FUNCTION__, whent, PyFloat_AsDouble(ot), ot);\n     }\n     *pwhen = whent;\n     return 1;\ndiff --git a/Python/pytime.c b/Python/pytime.c\nindex 1ef99aee74..7afa21df6b 100644\n--- a/Python/pytime.c\n+++ b/Python/pytime.c\n@@ -292,7 +292,7 @@ _PyTime_FromNanosecondsObject(_PyTime_t *tp, PyObject *obj)\n }\n\n #ifdef HAVE_CLOCK_GETTIME\n-static int\n+int __attribute__((visibility(\"default\")))\n pytime_fromtimespec(_PyTime_t *tp, struct timespec *ts, int raise)\n {\n     _PyTime_t t, nsec;\n@@ -326,6 +326,8 @@ pytime_fromtimespec(_PyTime_t *tp, struct timespec *ts, int raise)\n         t += nsec;\n     }\n\n+    printf(\"**** %-40s%ld\\n\", __FUNCTION__, t);\n+\n     *tp = t;\n     return res;\n }\n@@ -338,7 +340,7 @@ _PyTime_FromTimespec(_PyTime_t *tp, struct timespec *ts)\n #endif\n\n #if !defined(MS_WINDOWS)\n-static int\n+int __attribute__((visibility(\"default\")))\n pytime_fromtimeval(_PyTime_t *tp, struct timeval *tv, int raise)\n {\n     _PyTime_t t, usec;\n@@ -655,7 +657,7 @@ _PyTime_AsTimespec(_PyTime_t t, struct timespec *ts)\n }\n #endif\n\n-static int\n+int __attribute__((visibility(\"default\")))\n py_get_system_clock(_PyTime_t *tp, _Py_clock_info_t *info, int raise)\n {\n #ifdef MS_WINDOWS\n@@ -765,7 +767,7 @@ py_get_system_clock(_PyTime_t *tp, _Py_clock_info_t *info, int raise)\n     return 0;\n }\n\n-_PyTime_t\n+_PyTime_t __attribute__((visibility(\"default\")))\n _PyTime_GetSystemClock(void)\n {\n     _PyTime_t t;\n@@ -777,10 +779,12 @@ _PyTime_GetSystemClock(void)\n     return t;\n }\n\n-int\n+int __attribute__((visibility(\"default\")))\n _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)\n {\n-    return py_get_system_clock(t, info, 1);\n+    int ret = py_get_system_clock(t, info, 1);\n+    printf(\"**** %-40s%ld\\n\", __FUNCTION__, *t);\n+    return ret;\n }\n\n #if __APPLE__\n\nКак заплата выглядит можно посмотреть в этом примере (вырезаны только релевантные куски кода из pytime.c и timemodule.c, которые тут немного упрощены и добавлены пояснения для наглядности):\n\nПропатченый и упрощенный исходный код на сях ...\n// == составляющие time.time(), до результата 1640M (гуд) или 1705M (бэд) ==\n\n// делает из длинного целого питоний объект с double (posix epoch секунды) внутри:\n static PyObject*\n _PyFloat_FromPyTime(_PyTime_t t)\n {\n     double d = _PyTime_AsSecondsDouble(t); // фактически делим на 1e9\n     PyObject* op = PyFloat_FromDouble(d);  // оборачиваем double в PyObject\n+    printf(\"**** %-40s%.3lf  ooo>>  %.3lf (O:%p)\\n\", __FUNCTION__, d, PyFloat_AsDouble(op), op);\n     return op;\n }\n\n// делает из структуры timespec длинное целое (int64_t), наносекунды от posix epoch:\nstatic int\npytime_fromtimespec(_PyTime_t *tp, struct timespec *ts, int raise)\n{\n    _PyTime_t t;\n\n     t = (_PyTime_t)ts->tv_sec;\n     t *= SEC_TO_NS; // 1e9\n     t += ts->tv_nsec;\n+    printf(\"**** %-40s%ld\\n\", __FUNCTION__, t);\n     *tp = t;\n     return res;\n }\n\n// системное время в наносекундах от posix epoch, когда defined(HAVE_CLOCK_GETTIME),\n// что справедливо для нужной нам машинки:\n static int\n py_get_system_clock(_PyTime_t *tp, _Py_clock_info_t *info, int raise)\n {\n     struct timespec ts;\n...\n     err = clock_gettime(CLOCK_REALTIME, &ts);\n     if (err) {...}\n     if (pytime_fromtimespec(tp, &ts, raise) < 0) {\n         return -1;\n     }\n\n     if (info) {...}\n...\n     return 0;\n }\n\n // платформо-независимая внутрянка time.time():\n int\n _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)\n {\n     int ret = py_get_system_clock(t, info, 1);\n+    printf(\"**** %-40s%ld\\n\", __FUNCTION__, *t);\n     return ret;\n }\n\n// == составляющие time.localtime(), где наблюдается 1674M ==\n static int\n parse_time_t_args(PyObject *args, const char *format, time_t *pwhen)\n {\n     PyObject *ot = NULL;\n     time_t whent;\n\n     if (!PyArg_ParseTuple(args, format, &ot))\n         return 0;\n...\n         // PyObject в double и округляем до целого (в time_t, posix epoch секунды):\n         if (_PyTime_ObjectToTime_t(ot, &whent, _PyTime_ROUND_FLOOR) == -1)\n             return 0;\n+        printf(\"**** %-40s%.ld....  <<ooo  %.3lf (O:%p)\\n\", __FUNCTION__, whent, PyFloat_AsDouble(ot), ot);\n...\n     *pwhen = whent;\n     return 1;\n }\n\n\nСкрипт для всего действа выглядит как то так:\ncd /tmp/python-test\n\n# клонируем (3.10.2) из репозитария в текущую папку:\ngit clone --branch v.3.10.2 --depth 1  https://github.com/python/cpython.git .\n\n# накатываем patch (сначала сохранив содержимое в patch-debug-time.diff):\ngit apply patch-debug-time.diff\n\n# собираем питон в папке build/debug:\nmkdir -p ./build/debug && cd ./build/debug\n../../configure CFLAGS='-DPy_DEBUG' --with-pydebug\nmake\n\n# запускаем тест и ждем прыжка во времени:\nprintf 'typedef clockid_t = enum (CLOCK_REALTIME=0, CLOCK_MONOTONIC=1);\\ntypedef timespec = struct(long, long);\\ntypedef tm = struct(int, int, int, int, int, int, int, int, int);\\nint clock_gettime(clockid_t, +timespec*);\\ndouble floor(void*, double);\\ntm* localtime_r(long*, +tm*);\\n' > /tmp/ltrace.conf\nltrace -e '*gettime+floor+localtime_r' -F /tmp/ltrace.conf \\\n  ./python -c $'import time\\nwhile True: t=time.time(); lt=time.localtime(t); print(\"%.3f\\t%.3f\\t%s\" % (time.monotonic(), t, time.strftime(\"%Y-%m-%dT%H:%M:%S\", lt))), time.sleep(0.5)'\nЗаплатка и скрипт улетели до бенефициара и ожидаемо через пару дней прилетел ответ, где наглядно так прослеживается, что питон неуиноватый прыжки в будущее наблюдаются там где они тупо не должны наблюдаться (а они, как тот суслик, в наличии). Однако всё по порядку… \n\nРезультат исполнения теста ...\npython->clock_gettime(CLOCK_MONOTONIC, { 1351882, 719005224 })                                          = 0\n**** pytime_fromtimespec                     1351882719005224\npython->clock_gettime(CLOCK_REALTIME, { 1642516505, 739162789 })                                        = 0\n**** pytime_fromtimespec                     1642516505739162789\n**** _PyTime_GetSystemClockWithInfo          1642516505739162789\n**** _PyFloat_FromPyTime                     1642516505.739  ooo>>  1642516505.739 (O:0x7f17b4b84400)\n**** parse_time_t_args                       1642516505....  <<ooo  1642516505.739 (O:0x7f17b4b84400)\npython->localtime_r(1642516505, { 5, 35, 6, 18, 0, 122, 2, 17, 0 })                                     = { 5, 35, 6, 18, 0, 122, 2, 17, 0 }\npython->clock_gettime(CLOCK_MONOTONIC, { 1351883, 222098983 })                                          = 0\n**** pytime_fromtimespec                     1351883222098983\n**** _PyFloat_FromPyTime                     1351883.222  ooo>>  1351883.222 (O:0x7f17b4b84220)\n1351883.222 1642516505.739  2022-01-18T06:35:05 --\npython->clock_gettime(CLOCK_MONOTONIC, { 1351883, 222672553 })                                          = 0\n**** pytime_fromtimespec                     1351883222672553\npython->clock_gettime(CLOCK_REALTIME, { 1642516506, 243048649 })                                        = 0\n**** pytime_fromtimespec                     1642516506243048649\n**** _PyTime_GetSystemClockWithInfo          1642516506243048649\n**** _PyFloat_FromPyTime                     1676140652.455  ooo>>  1676140652.455 (O:0x7f17b4b84220)\n**** parse_time_t_args                       1676140652....  <<ooo  1676140652.455 (O:0x7f17b4b84220)\npython->localtime_r(1676140652, { 32, 37, 10, 11, 1, 123, 6, 41, 0 })                                   = { 32, 37, 10, 11, 1, 123, 6, 41, 0 }\npython->clock_gettime(CLOCK_MONOTONIC, { 1351883, 724655853 })                                          = 0\n**** pytime_fromtimespec                     1351883724655853\n**** _PyFloat_FromPyTime                     1384655.922  ooo>>  1384655.922 (O:0x7f17b4b84400)\n1415970.483 1707394536.366  2023-02-11T10:37:32 --\npython->clock_gettime(CLOCK_MONOTONIC, { 1351883, 724982418 })                                          = 0\n**** pytime_fromtimespec                     1351883724982418\npython->clock_gettime(CLOCK_REALTIME, { 1642516506, 751439357 })                                        = 0\n**** pytime_fromtimespec                     1642516506751439357\n**** _PyTime_GetSystemClockWithInfo          1642516506751439357\n**** _PyFloat_FromPyTime                     1642516506.751  ooo>>  1642516506.751 (O:0x7f17b4b84400)\n**** parse_time_t_args                       1642516506....  <<ooo  1642516506.751 (O:0x7f17b4b84400)\npython->localtime_r(1642516506, { 6, 35, 6, 18, 0, 122, 2, 17, 0 })                                     = { 6, 35, 6, 18, 0, 122, 2, 17, 0 }\npython->clock_gettime(CLOCK_MONOTONIC, { 1351884, 293524900 })                                          = 0\n**** pytime_fromtimespec                     1351884293524900\n**** _PyFloat_FromPyTime                     1351884.294  ooo>>  1351884.294 (O:0x7f17b4b84220)\n1351884.294 1642516506.751  2022-01-18T06:35:06 --\npython->clock_gettime(CLOCK_MONOTONIC, { 1351884, 321497772 })                                          = 0\n**** pytime_fromtimespec                     1351884321497772\npython->clock_gettime(CLOCK_REALTIME, { 1642516507, 359952744 })                                        = 0\n**** pytime_fromtimespec                     1642516507359952744\n**** _PyTime_GetSystemClockWithInfo          1642516507359952744\n**** _PyFloat_FromPyTime                     1642516507.360  ooo>>  1642516507.360 (O:0x7f17b4b84220)\n**** parse_time_t_args                       1642516507....  <<ooo  1642516507.360 (O:0x7f17b4b84220)\npython->localtime_r(1642516507, { 7, 35, 6, 18, 0, 122, 2, 17, 0 })                                     = { 7, 35, 6, 18, 0, 122, 2, 17, 0 }\npython->clock_gettime(CLOCK_MONOTONIC, { 1351884, 863699790 })                                          = 0\n**** pytime_fromtimespec                     1351884863699790\n**** _PyFloat_FromPyTime                     1351884.864  ooo>>  1351884.864 (O:0x7f17b4b84400)\n1351884.864 1642516507.360  2022-01-18T06:35:07 --\npython->clock_gettime(CLOCK_MONOTONIC, { 1351884, 889163504 })                                          = 0\n**** pytime_fromtimespec                     1351884889163504\npython->clock_gettime(CLOCK_REALTIME, { 1642516507, 918812741 })                                        = 0\n**** pytime_fromtimespec                     1642516507918812741\n**** _PyTime_GetSystemClockWithInfo          1642516507918812741\n**** _PyFloat_FromPyTime                     1676140654.381  ooo>>  1676140654.381 (O:0x7f17b4b84400)\n**** parse_time_t_args                       1676140654....  <<ooo  1676140654.381 (O:0x7f17b4b84400)\npython->localtime_r(1676140654, { 34, 37, 10, 11, 1, 123, 6, 41, 0 })                                   = { 34, 37, 10, 11, 1, 123, 6, 41, 0 }\npython->clock_gettime(CLOCK_MONOTONIC, { 1351885, 400173973 })                                          = 0\n**** pytime_fromtimespec                     1351885400173973\n**** _PyFloat_FromPyTime                     1384657.598  ooo>>  1384657.598 (O:0x7f17b4b84220)\n1415972.159 1707394538.291  2023-02-11T10:37:34 --\npython->clock_gettime(CLOCK_MONOTONIC, { 1351885, 400525494 })                                          = 0\n**** pytime_fromtimespec                     1351885400525494\npython->clock_gettime(CLOCK_REALTIME, { 1642516508, 421229660 })                                        = 0\n**** pytime_fromtimespec                     1642516508421229660\n**** _PyTime_GetSystemClockWithInfo          1642516508421229660\n**** _PyFloat_FromPyTime                     1642516508.421  ooo>>  1642516508.421 (O:0x7f17b4b84220)\n**** parse_time_t_args                       1642516508....  <<ooo  1642516508.421 (O:0x7f17b4b84220)\npython->localtime_r(1642516508, { 8, 35, 6, 18, 0, 122, 2, 17, 0 })                                     = { 8, 35, 6, 18, 0, 122, 2, 17, 0 }\npython->clock_gettime(CLOCK_MONOTONIC, { 1351885, 902929970 })                                          = 0\n**** pytime_fromtimespec                     1351885902929970\n**** _PyFloat_FromPyTime                     1351885.903  ooo>>  1351885.903 (O:0x7f17b4b84400)\n1351885.903 1642516508.421  2022-01-18T06:35:08 --\n\nКстати, внимательный читатель возможно заметил, что цифры успели немного подрасти, что 1642M (которая месяц назад была еще 1640M), что 1676M (которая ранее была 1674M), и сделали они это пропорционально (что возможно еще один аргумент против битой памяти).\nБерём первый кусок в котором наблюдаем 1676M вместо положенного 1642M и пытаемся через него выйти на того \"мерцающего\" вдалеке суслика. \nИтак собственно выхлоп теста для первой аномалии (diff синтакс для ударения, т.е. подсветки первого следа зверька):\n  python->clock_gettime(CLOCK_REALTIME, { 1642516506, 243048649 })                                        = 0\n  **** pytime_fromtimespec                     1642516506243048649\n  **** _PyTime_GetSystemClockWithInfo          1642516506243048649\n- **** _PyFloat_FromPyTime                     1676140652.455  ooo>>  1676140652.455 (O:0x7f17b4b84220)\n  **** parse_time_t_args                       1676140652....  <<ooo  1676140652.455 (O:0x7f17b4b84220)\n  python->localtime_r(1676140652, { 32, 37, 10, 11, 1, 123, 6, 41, 0 })                                   = { 32, 37, 10, 11, 1, 123, 6, 41, 0 }\n  python->clock_gettime(CLOCK_MONOTONIC, { 1351883, 724655853 })                                          = 0\n  **** pytime_fromtimespec                     1351883724655853\n  **** _PyFloat_FromPyTime                     1384655.922  ooo>>  1384655.922 (O:0x7f17b4b84400)\n  1415970.483   1707394536.366  2023-02-11T10:37:32 --\nТ.е. смотрим выше в код для _PyFloat_FromPyTime, и что мы там видим? А собственно, то что _PyTime_AsSecondsDouble(t) вдруг возвращает 1676M вместо 1642M, которое затем, уже в испорченном виде, оборачивается в объект.\r\nИ это при верном t, которое было 1642516506243048649, что при делении на 1e9 вдруг почему-то даёт нам 1676140652.455!\nЕсли же мы заглянем в _PyTime_AsSecondsDouble, которая по всей видимости и есть суть искомая машина времени, нам там наглядно продемонстрируют глубокий философский смысл фразы \"Суслика видишь?.. Вот и я не вижу… А он есть\":\ndouble\n_PyTime_AsSecondsDouble(_PyTime_t t)\n{\n    /* volatile avoids optimization changing how numbers are rounded */\n    volatile double d;\n\n    if (t % SEC_TO_NS == 0) {\n        _PyTime_t secs;\n        /* Divide using integers to avoid rounding issues on the integer part.\n           1e-9 cannot be stored exactly in IEEE 64-bit. */\n        secs = t / SEC_TO_NS;\n        d = (double)secs;\n    }\n    else {\n        d = (double)t; /* Ты понимаешь, что это значит? */\n        d /= 1e9;      /* Это значит, что эта пакость не работает! */\n    }\n    return d;\n}\nПоскольку никакой магии тут нет и быть не может: volatile для d — это попытка избежать оптимизации, изменяющей порядок округления чисел, а первая ветка служит для предотвращения небольшой ошибки в расчетах на системах с 64-битным FP, если число делится на единицу с 9 нулями без остатка (имеем только круглые секунды). Т.е. деление организованно тут либо в целочисленной для int64_t, либо в FP арифметике для double (зависит от остатка при делении t на SEC_TO_NS, то есть на тот самый лярд).\nЕсли короче, то на самом деле эта функция абсолютно детерминирована, что полностью исключает какие-либо отклонения от совершенно обычного действия деления t / 1e9. Что для 1642516506243048649 / 1e9 должно быть 1642516506.243 а никак не 1676140652.455.\r\nНу, в случае корректно работающей системы, естественно.\nОтсюда вывод, что она (та система) работает некорректно. Как собственно в принципе и предполагалось...\n\"А где же тот 1707M (который результат time.time()) в промежуточных значениях\" спросит цепкий и наблюдательный читатель. И я ему незамедлительно отвечу: либо мы до них еще не добрались (нужна еще парочка printf где-нибудь), либо это так не дебажится (хайзенбаг тут всё-таки или погулять вышел), либо, что скорее всего, мы имеем похожую ошибку в FP при округлении числа (или форматировании оного на %.3f) в питоньей реализации интерполяции %-оператором.\nКак-то так.\nВ результате подозрение на следующие причины:\n\nлибо FPU, например что-либо похожее на \"broken AMD FPU FIP/FDP/FOP leak\" XSA-172 (заметим что здесь как и у человека речь про AMD)\nлибо поврежденная память (странно только что оно всё на удивление стабильно и при этом не проявляется нигде более, тем более если то, как оно выглядит, находится на стеке)\nлибо hypervisor, к примеру что-нибудь из оперы LazyFP и т.п. или как если бы кто-то пробует сам хост или какую-либо виртуалку на нем на exploit в сторону векторов типа branch predictor attack (типа тех же meltdown/spectre) и тем самым вызывает поломку состояния машины/CPU/FPU и т.д.\n\nНа этом можно было бы и завершить, порекомендовав человеку либо как-то заставить провайдера сменить для виртуалки host, либо поменять собственно хостера.\nОднако, захотелось помочь людям выяснить что это такое за беда.\nНабросал на коленке небольшой скрипт, компилирующий простенький код на сях (безо всяких питонов) и запускающий его экзешник с целью проверить, что у нас тут собственно сломано FPU или память.\nЕсли в результате теста time-jump будет воспроизведен (правильные наносекунды, но неверные секунды), это скорее всего будет сигнализировать о «сломанном» FPU, в противном же случае это может сигнализировать о «сломанной» памяти, так как по сравнению с python, этот код всегда использует одни и те же адреса памяти в стеке или вообще только регистры.\nПока без ответа, два дня еще не прошло.\n[UPD] Всё — тема закрыта, суслик убег, магия кончилась: хост вылечился заменой CPU.\nЗа сим позвольте откланяться, всем участвовавшим большое спасибо. Ах да, ниже небольшой опрос, как говорится «Messieurs, faites vos jeux»... ",
   "  Только зарегистрированные пользователи могут участвовать в опросе. Войдите, пожалуйста. Что это всё-таки за зверь? \n            44.44%\n           FPU \n            40\n           \n            5.56%\n           CPU \n            5\n           \n            4.44%\n           память \n            4\n           \n            8.89%\n           питон \n            8\n           \n            8.89%\n           жук \n            8\n           \n            46.67%\n           суслик \n            42\n            \n       Проголосовали 90 пользователей. \n\n       Воздержались 38 пользователей. \n    "
]