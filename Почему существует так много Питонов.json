[
   "Почему существует так много Питонов?",
   "Питон изумителен.\n\r\nУдивительно, но это довольно неоднозначное заявление. Что я имею ввиду под “Питоном”? Может, абстрактный интерфейс Питона? Или CPython, распространенная реализация Питона (не путать с похожим по названию Cython)? Или я имею ввиду что-то совсем иное? Может, я косвенно ссылаюсь на Jython, или IronPython, или PyPy. Или может я отвлекся так сильно, что говорю о RPython или RubyPython (которые очень сильно отличаются).\n\r\nНе смотря на схожесть в названиях указанных выше технологий, некоторые из них имеют совсем другие задачи (или, как минимум, работают совершенно иными способами)\n\r\nПри работе с Питоном я столкнулся с кучей таких технологий. Инструменты *ython. Но лишь недавно я уделил время, чтобы разобраться, что они собой представляют, как они работают и почему они (каждая по-своему) необходимы.\n\r\nВ этом посте я начну с нуля и пройдусь по разным реализациям Питона, а закончу подробным введением в PyPy, за которым, по моему мнению, будущее языка.\n\r\nВсе начинается с понимания того, чем на самом деле является “Питон”.\n\r\nЕсли у вас хорошее понимание машинного кода, виртуальных машин и так далее, можете пропустить этот раздел.\n\nПитон интерпретируемый или компилируемый?\n\r\nЭто распространенный источник непонимания среди новичков Питона.\n\r\nПервое, что необходимо понять: “Питон” – это интерфейс. Существует спецификация, описывающая, что должен делать Питон, и как он должен себя вести (что справедливо для любого интерфейса). И существует несколько имплементаций (что также справедливо для любого интерфейса).\n\r\nВторое: “интерпретируемый” и “компилируемый” это свойства имплементации, но не интерфейса.\n\r\nТак что сам вопрос не совсем корректен.\n\r\nВ случае с самой распространенной реализацией (CPython: написанный на C, часто называемый просто “Python”, и, конечно, именно тот, который вы используете, если понятия не имеете о чем я толкую) ответ: интерпретируемый, с некоторой компиляцией. CPython компилирует* исходный код на Питоне в байткод, а затем интерпретирует этот байткод, запуская его в процессе.\n\n* Замечание: это не совсем “компиляция” в традиционном смысле. Обычно, мы считаем, что “компиляция” это конвертация из высокоуровневого языка в машинный код. Тем не менее – в некотором роде это “компиляция”.\n\r\nДавайте изучим этот ответ получше, так как он поможет нам понять некоторые концепции, ожидающие нас в этой статье.\n\nБайткод или машинный код\n\r\nОчень важно понять разницу между байткодом и машинным (или нативным) кодом. Пожалуй, легче всего ее понять на примере:\n\r\n — Cи компилируется в машинный код, который впоследствии запускается напрямую процессором. Каждая инструкция заставляет процессор производить разные действия.\r\n — Java компилируется в байткод, который впоследствии запускается на Виртуальной машине Java (Java Virtual Machine, JVM), абстрактном компьютере, который запускает программы. Каждая инструкция обрабатывается JVM, который взаимодействует с компьютером.\n\r\nСильно упрощая: машинный код намного быстрее, но байткод лучше переносим и защищен.\n\r\nМашинный код может отличаться в зависимости от машины, тогда как байткод одинаковый на всех машинах. Можно сказать, что машинный код оптимизирован под вашу конфигурацию.\n\r\nВозвращаясь к CPython, цепочка операций выглядит следующим образом:\n\r\n1. CPython компилирует ваш исходный код на Питоне в байткод.\r\n2. Этот байткод запускается на виртуальной машине CPython.\n\nНовички зачастую допускают, что Питон компилируемый из-за наличия .pyc-файлов. Это отчасти верно: .pyc-файлы – это скомпилированный байткод, который впоследствии интерпретируется. Так что если вы запускали ваш код на Питоне, и у вас есть .pyc-файл, то во второй раз он будет работать быстрее, потому что ему не нужно будет заново компилироваться в байткод.\n\nАльтернативные виртуальные машины: Jython, IronPython и другие\n\r\nКак я говорил выше, у Питона существует несколько реализаций. Опять же, как говори-лось выше, самой популярной является CPython. Эта версия Питона написана на C и считается имплементацией “по умолчанию”.\n\r\nНо как насчет альтернатив? Одна из наиболее видных это Jython, реализация Питона на Java, которая использует JVM. В то время как CPython генерирует байткод для запуска на CPython VM, Jython генерирует байткод Java для запуска на JVM (это то же самое, что генерируется при компиляции программы на Java).\n\n\n\r\n“Зачем может понадобиться использовать альтернативную реализацию?”, спросите вы. Ну, для начала, разные реализации хорошо ладят с разными наборами технологий.\n\r\nCPython упрощает написание C-расширений для кода на Питоне потому что в конце он запускается интерпретатором Cи. Jython в свою очередь упрощает работу с другими программами на Java: вы можете импортировать любые Java-классы без дополнительных усилий, призывая и используя ваши Java-классы из программ на Jython. (Замечание: если вы еще не думали об этом всерьез, это довольно безумно. Мы дожили до того времени, когда можно смешивать разные языки и компилировать их в одну сущность. Как заметил Rostin, программы, смешивающие код на Фортране с Cи появились довольно давно, так что это не совсем новинка. Но это все же круто.)\n\r\nВ качестве примера, вот корректный код на Jython:\n\n[Java HotSpot(TM) 64-Bit Server VM (Apple Inc.)] on java1.6.0_51\r\n>>> from java.util import HashSet\r\n>>> s = HashSet(5)\r\n>>> s.add(\"Foo\")\r\n>>> s.add(\"Bar\")\r\n>>> s\r\n[Foo, Bar]\n\nIronPython это другая популярная реализация Питона, написанная полностью на C# и предназначенная для .NET. В частности, она запускается на виртуальной машине .NET, если ее можно так назвать, на Common Language Runtime (CLR), от Майкрософт, сравнимым с JVM.\n\r\nМожно сказать, что Jython: Java :: IronPython: C#. Они работают на соответствующих виртуальных машинах, есть возможность импортировать классы C# в код IronPython и классы Java в код Jython, и так далее.\n\r\nВполне реально выжить, не прикасаясь к ни к чему, кроме CPython. Но, переходя на другие имплементации, вы получаете преимущество, в основном из-за используемого стека технологий. Используете много языков, основанных на JVM? Jython может вам подойти. Все на .NET? Возможно, стоит попробовать IronPython (и, возможно, вы уже сделали).\n\n\n\r\nКстати, хоть это и не станет причиной для перехода на другую имплементацию, стоит упомянуть, что имплементации эти на самом деле отличаются поведением. Это касается не только способов интерпретации кода на Питоне. Однако эти отличия, как правило, не-значительны, они исчезают и появляются со временем из-за активной разработки. К примеру, IronPython использует строки Unicode по умолчанию; однако CPython использует ASCII в версиях 2.x (выдавая ошибку UnicodeEncodeError для не-ASCII символов), и при этом поддерживает символы Unicode по умолчанию в версиях 3.x.\n\nКомпиляция на лету (Just-in-Time Compilation): PyPy и будущее\n\r\nИтак, у нас есть имплементация Питона, написанная на Си, еще одна – на Java, и третья на C#. Следующий логичный шаг: имплементация Питона, написанная на… Питоне. (Подготовленный читатель заметит, что это утверждение немного обманчиво).\n\r\nВот почему это может сбивать с толку. Для начала, давайте обсудим компиляцию на лету (just-in-time или JIT).\n\nJIT. Почему и как\n\r\nНапомню, что нативный машинный код намного быстрее байткода. Ну, а что, если бы можно было компилировать часть байткода и запускать его как нативный код? Пришлось бы “заплатить” некоторую цену (иными словами: время) за компиляцию байткода, но если результат будет работать быстрее, то это здорово! Этим и мотивируется JIT-компиляция, гибридная техника, которая совмещает в себе преимущества интерпретато-ров и компиляторов. В двух словах – JIT старается использовать компиляцию, чтобы ускорить систему интерпретации.\n\r\nНапример, вот распространенный подход JIT:\n\n\nОпределить байткод, который запускается часто.\nСкомпилировать его в нативный машинный код.\nЗакэшировать результат.\nВсегда когда необходимо запустить тот же самый байткод, использовать уже скомпилированный машинный код и пожинать плоды (в частности, прирост скорости).\n\n\r\nВ этом вся суть PyPy: использовать JIT в Питоне (в дополнении можно найти предыдущие попытки). Конечно, есть и другие цели: PyPy нацелен на кроссплатформенность, работу с небольшим количеством памяти и поддержку stackless (отказа от стека вызовов языка Си в пользу собственного стека). Но JIT это главное преимущество. В среднем на основе временных тестов, фактор ускорения составляет 6.27. Более подробные данные можно получить из схемы от PyPy Speed Center:\n\n\n\nВ PyPy сложно разобраться\n\r\nУ PyPy есть огромный потенциал, и в данный момент он хорошо совместим с CPython (так что на нем можно запускать Flask, Django, и т.д.).\n\r\nНо с PyPy есть много путаницы. (оцените, к примеру, это бессмысленное предложение создать PyPyPy…). По моему мнению основная причина в том, что PyPy одновременно является:\n\r\n1. Интерпретатором Питона, написанным на RPython (не Python (я обманул вас до этого)). RPython это подмножество Python со статичной типизацией. В Python, вести тщательные беседы о типах “в целом невозможно” почему это так сложно? рассмотрите следующее:\n\n x = random.choice([1, \"foo\"])\n\r\nэто корректный код на Python (спасибо Ademan‘у). Какой тип у x? Как мы можем обсуждать типы переменных, когда типы даже не форсируются?). В RPython мы жертвуем некоторой гибкостью, но взамен получаем возможность гораздо проще управлять памятью и много чего еще, что помогает при оптимизации.\n\r\n2. Компилятором, который компилирует код на RPython в разные форматы и поддерживает JIT. Платформой по-умолчанию является Си, то есть компилятор RPython-в-Си, но в качестве целевой платформы также можно выбрать JVM и другие.\n\r\nДля простоты описания, я буду называть их PyPy (1) и PyPy (2).\n\r\nЗачем могут понадобиться эти две вещи, и почему – в одном наборе? Думайте об этом так: PyPy (1) это интерпретатор, написанный на RPython. То есть он берет пользовательский код на Питоне и компилирует его в байткод. Но чтобы сам интерпретатор (написанный на RPython) мог работать, он должен быть интерпретирован другой реализацией Пи-тона, верно?\n\r\nИтак, можно просто использовать CPython чтобы запускать интерпретатор. Но это будет не слишком быстро.\n\r\nВместо этого мы используем PyPy (2) (называемый RPython Toolchain) чтобы компилировать интерпретатор PyPy в код для другой платформы (например, C, JVM, или CLI) для запуска на конечной машине, с добавлением JIT. Это волшебно: PyPy динамически добавляет JIT к интерпретатору, генерируя собственный компилятор! (Опять же, это безумие: мы компилируем интерпретатор, добавляя другой отдельный, самостоятельный компилятор).\n\r\nВ конце концов результатом будет самостоятельный исполняемый файл, который интерпретирует исходный код на Питоне и использует оптимизацию JIT. То, что нужно! Понять сложновато, но, возможно, эта схема поможет:\n\n\n\r\nПовторим: настоящая красота PyPy в том, что мы можем написать себе кучу разных интерпретаторов Питона на RPython не волнуясь о JIT (не считая пары деталей). После этого PyPy реализует для нас JIT, используя RPython Toolchain/PyPy (2).\n\r\nНа самом деле, если копнуть глубже в абстракцию, теоретически можно написать интерпретатор любого языка, направить его в PyPy и получить JIT для этого языка. Это возможно потому, что PyPy концентрируется на оптимизации самого интерпретатора, а не деталей языка, который тот интерпретирует.\n\r\nВ качестве отступления я бы хотел заметить, что сам JIT совершенно восхитителен. Он использует технику под названием “отслеживание” (tracing), которая работает следующим образом:\n\n\nЗапустить интерпретатор и интерпретировать все (не добавляя JIT).\nПровести легкое профилирование интерпретированного кода. \nОпределить операции, которые уже выполнялись ранее. \nСкомпилировать эти части кода в машинный код. \n\n\r\nУзнать больше можно из этой легкодоступной и очень интересной публикации.\n\r\nПодытожим: мы используем PyPy-компилятор RPython-в-Си (или другую целевую плат-форму), чтобы скомпилировать реализованный на RPython интерпретататор PyPу.\n\nЗаключение\n\r\nПочему все это так восхитительно? Почему стоит гнаться за этой безумной идеей? По-моему, Алекс Гейнор объяснил это очень хорошо в своем блоге: “[За PyPy будущее] потому что [он] более быстрый, более гибкий и является лучшей платформой для развития Питона”.\n\r\nВкратце:\n\n\nОн быстрый – потому что компилирует исходный код в нативный код (используя JIT).\nОн гибкий – потому что добавляет JIT в интерпретатор без особых усилий. \nОн гибкий (опять) – потому что вы можете писать интерпретаторы в RPython, что впоследствии упрощает расширение по сравнению с тем же Си (на самом деле упрощает настолько, что даже есть инструкция по написанию собственных интерпретаторов). \n\n\nДополнение: другие названия, которые вы, возможно, слышали\n\nPython 3000 (Py3k): альтернативное название Python 3.0, основной релиз Питона с обратной совместимостью, который появился в 2008. году. Команда Py3k предсказала, что новой версии понадобится примерно пять лет чтобы полностью прижиться. И в то время, как большинство (внимание: надуманное утверждение) разработчиков на Питоне продолжают использовать Python 2.x, люди все больше задумываются о Py3k.\n\nCython: надмножество Python, включающее возможность вызывать функции Си.\n\nЗадача: позволить писать расширения Си для программ на Питоне. \nТакже позволяет добавлять статическую типизацию в существующий код на Питоне, что после повторной компиляции может помочь достичь похожей на Си производительности. \nНапоминает PyPy, но это не то же самое. В случае с Cython вы форсируете типизацию в пользовательском коде перед подачей компилятору. В PyPy вы пишете старый добрый Python, а компилятор отвечает за любую оптимизацию. \n\n\nNumba: “специализированный just-in-time компилятор”, который добавляет JIT в снабженный примечаниями код на Питоне. Проще говоря, вы даете ему подсказки, а он ускоряет некоторые части вашего кода. Numba является частью дистрибутива Anaconda набора пакетов для анализа и управления данными.\n\nIPython: сильно отличается от всего, что мы обсудили. Вычислительная среда для Питона. Интерактивная, с поддержкой GUI-пакетов, браузеров и так далее.\n\nPsyco: модуль расширения Питона, одна из первых попыток Питона в области JIT. Давно помечен как “неподдерживаемый и мертвый”. Главный разработчик Psyco Армин Риго сейчас работает над PyPy. \n\nПривязки к языкам\n\n\n RubyPython: мост между виртуальными машинами Ruby и Python. Позволяет встраивать код на Питоне в код на Ruby. Вы обозначаете, где начинается и заканчивается Питон, а RubyPython обеспечивает передачу данных между виртуальными машинами.\n\n PyObjc: языковое соединение между Python и Objective-C, которые ведет себя как мост между ними. На практике это означает, что вы можете использовать библиотеки Objective-C (включая все, что нужно для создания приложения под OS X) в коде на Питоне, и модули Питона в коде на Objective-C. Это удобно, потому что CPython написан на Си, который является подмножеством Objective-C.\n\n PyQt: в то время как PyObjc позволяет связать Питон с компонентами OS X GUI, PyQt делает то же для фреймворка Qt. Это дает возможность создавать полноценные графические интерфейсы, обращаться к SQL базам данных и так далее. Еще один инструмент, нацеленный на перенос простоты Питона в другие фреймворки.\n\n\n\nJavaScript фреймворки\n\n\n pyjs (Pyjamas): фреймворк для создания веб и десктопных приложений на Питоне. Включает в себя компилятор Python-в-JavaScript, набор виджетов и некоторые другие инструменты.\n\n Brython: виртуальная машина Python, написанная на Javascript. Позволяет запустить код на Py3k в веб-браузере.\n\n "
]