[
   "Тестируем вёрстку правильно",
   "\nЧто не так с тестированием вёрстки\r\nМы часто им пренебрегаем. Написание функциональных, интеграционных и юнит-тестов давно стало повсеместной практикой. Вёрстке мы обычно уделяем гораздо меньше времени.\n\r\nПроблема тестирования вёрстки в том, что только живой человек может сказать, хорошо свёрстан блок на странице или нет. Поэтому чаще всего мы тестируем HTML и CSS вручную: проверяем, как будет вести себя блок, если в нем будет слишком много (или слишком мало) текста или дочерних элементов; смотрим, чтобы все возможные варианты отображения блока смотрелись корректно; помним о том, как блоки должны адаптироваться к разным устройствам и разрешениям экрана.\n\nКак тестировать вёрстку правильно\r\nНам не нужно придумывать ничего нового. Мы можем применить те же подходы, которые используем при написании автотестов.\n\r\nСначала нужно посмотреть на требования, дизайн. На основе этого составить список всех значимых состояний приложения, которые нужно проверить. Далее, дело за малым — проверить каждый тест-кейс.\n\r\nВ статье я расскажу, как мы создали для себя Makeup, как изменили свой процесс разработки интерфейсов и как это упростило нам жизнь.\n\r\nMakeup — графический интерфейс для быстрого и комфортного ручного регрессионного тестирования вёрстки, основанной на методологии BEM. Это инструмент, для которого мы готовим тестовые данные так, чтобы можно было проинициализировать любой независимый блок с разными данными и быстро посмотреть его во всех интересующих нас состояниях.\n\r\nОписанный подход может помочь, если на вашем проекте соблюдаются 2 условия:\n\n\nу вас есть эталонные дизайн для всех блоков, и вы хотите, чтобы ваш проект точно соответствовал этому дизайну;\nвы придерживаетесь BEM-методологии в HTML и CSS.\n\r\nА теперь обо всём по порядку.\n\nКак измерить качество вёрстки\r\nПервая версия Makeup (тогда у него ещё не было имени) возникла в файле spec/index.html. На этой странице прогонялись юнит-тесты по всем модулям (читай: блокам) нашего приложения. Всё было традиционно: мы инициализировали каждый модуль с разными наборами тестовых данных и проверяли тестами то, что нас интересовало. \n\r\nНо этого было недостаточно. Несмотря на то, что эти тесты были сильно связаны с вёрсткой, они не могли ответить на вопрос, хорошо ли свёрстан модуль и правильно ли он будет вести себя в разных обстоятельствах. \n\r\nВ сети можно найти огромное количество чек-листов на качество вёрстки. Проверку многих пунктов из них можно легко поручить анализаторам кода. Но обычно эти чек-листы проверяют качество работы по косвенным или нерелевантным признакам. \n\r\nПо большому счету, критериев качества вёрстки всего два:\n\n\nсоответствие макету: вёрстка должна быть идентична дизайну.\nработоспособность: вёрстка должна отображаться в браузере пользователя на всех устройствах, которые нас интересуют.\n\r\nПри несоблюдении любого из двух пунктов проделанная работа не имеет никакого смысла.\n\nКак проверить соответствие макету\r\nСравнить вёрстку с исходным макетом и найти отличия. Но это порой не так просто. Помните, в детских журналах были головоломки «найди 10 отличий»?\n\n\n\r\nЛюбой инженер мгновенно предложит очевидное решение, как проще находить отличия. Достаточно наложить одно изображение на другое и верхнее изображение сделать полупрозрачным. \n\r\nМожно сделать ещё удобнее — инвертировать цвета для верхнего полупрозрачного изображения. Тогда при идеальном совпадении мы должны увидеть однородный серый фон.\n\n\n\nЗачем для этого специальный инструмент\r\nДля реализации подобной задумки не нужен специальный инструмент. Если нужно сравнить вёрстку с исходным дизайном страницы сайта, то такой подход можно реализовать прямо в браузере.\n\n1. Добавляем картинку с макетом \n<img src=\"index.png\" width=\"1280\" height=\"2000\" id=\"psd\">\n\n2. Позиционируем поверх свёрстанной страницы\n#psd {\n\t/* Позиционируем макет */\n\tposition: absolute;\n\ttop: 0;\n\tleft: 50%;\n\tmargin: 0 0 0 -640px;\n\n\t/* Делаем его полупрозрачным */\n\topacity: .5;\n\n\t/* Оставляем возможность взаимодействия с элементами */\n\tpointer-events: none;\n\n\t/* Инвертируем изображение в вашем любимом -webkit (-blink) браузере */\n\t-webkit-filter: invert(100%);\n\t}\nbody:hover #psd {\n\t/* Прячем картинку при наведении */\n\topacity: 0;\n\t}\n\r\nПо такому принципу работает огромное количество существующих инструментов: \n\n\nJavaScript-плагины\n\nResemble.js\n\nРасширения для браузера\n\nPerfectPixel\n1px\n\n\r\nПри желании вы найдёте ещё несколько десятков или сотен таких инструментов.\n\nВ чём же проблема\r\nЭтот подход применим только в том случае, когда при разработке мы можем построить однозначное соответствие между макетами и страницами верстки.\n\n\r\nНа деле мы всё чаще работаем со сложными веб-приложениями. И обычно мы не используем термин «страница». В привычных нам терминах веб-приложение с точки зрения вёрстки состоит из произвольного набора BEM-блоков и их состояний.\n\n\n\r\nСостояние блока — это его конечное отображение при определенном наборе элементов, модификаторов и при определенном контенте. Другими словами, каждое состояние блока — это один кейс его использования.\n\r\nНа практике это значит, что если, к примеру, у вас на проекте всего 100 независимых блоков, и для каждого из них предусмотрено всего 10 значимых кейсов использования, то вам придется помнить о 1000 уникальных состояний вашего приложения.\n\r\nМожно разбивать вёрстку на блоки поменьше, уменьшая количество состояний в каждом, но порядок числа вряд ли сильно изменится. \n\r\n1000 состояний — это очень много. Ни один человек не в состоянии удержать всё это в голове. И тем более быть уверенным в качестве вёрстки каждого блока.\n\nКак я делал раньше\r\nРаньше при разработке сложных блоков с большим количеством состояний для сравнения верстки отдельного блока с дизайном я использовал невероятно медленный способ.\n\n\n⌘ + Shift + Control + 4 выделяем область страницы с блоком, делаем скриншот в буфер обмена\n⌘ + Tab перемещаемся в соседнюю вкладку с Фотошопом\n⌘ + v вставляем скриншот\n⌘ + 5 выставляем слою прозрачность 50%\nv выбираем инструмент Move Tool\nShift + Arr или Arr × n раздвигаем до тех пор, пока точно не совместим с макетом\nDelete\n\r\nПосле этого правим CSS и повторяем всю последовательность заново. Пока макет не станет идеальным.\n\r\nЭту последовательность можно научиться выполнять по-настоящему быстро, но процесс всё равно будет занимать огромное количество времени. Но такой подход никогда не даст уверенности при регрессии или рефакторинге. Да и заниматься подобной ерундой не хочется.\n\nКак мы сделали ещё один инструмент\r\nМы не нашли инструмент, который бы нам позволил в любой момент времени…\n\n\nиметь возможность быстро и комфортно проверить соответствие блока исходным дизайн-макетам и продуктовым требованиям;\nбыть уверенным в том, что все значимые кейсы использования блока работают корректно;\nпри внесении изменений в блок просто и быстро проверить, что все предыдущие кейсы использования не сломаны;\nпроводить регрессионное тестирование вёрстки;\nиметь обзорную карту проекта с точки зрения вёрстки.\n\r\nПоэтому мы решили сделать для себя Makeup. \n\r\nСначала мы добавили сравнение с дизайном на страницу с юнит-тестами. Затем добавили пару ползунков для управления отображением блоков. А со временем всё это переросло в отдельный интерфейс, который стал основой рабочего процесса разработки интерфейсов в нашей команде.\n\n\r\nНа этой иллюстрации почти все возможности Makeup. Это невероятно простой инструмент.\n\nЧто нужно для реализации\n\nРесурсы вашего приложения: шаблоны (или просто HTML), стили, JavaScript-код, графику — всё, что есть в вёрстке.\nИзображения с исходным дизайном блоков в различных состояниях.\nКонфигурационный файл, который покажет «Makeup», каким образом всё перечисленное можно связать воедино.\n\n\n\r\nВы можете решить, что написание и поддержка актуальных конфигурационных файлов — немыслимая задача. При разработке приложения мы хотим, тратя минимальные усилия на описание структуры блоков, иметь инструмент, который поможет держать под контролем всю вёрстку. Для того, чтобы решить эту задачу, надо тесно интегрировать такой подход со сборкой вашего приложения.\n\r\nНаша команда почти полностью собирает конфигурацию автоматически на основе имеющихся тестовых данных. Вручную остается дописать только «заплатки» стилей, сниппеты и ссылки на документацию. На этапе сборки приложения формируются все необходимые конфигурационные файлы и создаётся отдельный порт, на котором запущен Makeup.\n\n\nКак можно использовать\r\nВ нашей команде Makeup — основа разработки интерфейса приложения. Мы активно используем его на всех этапах жизни блока.\n\n\nРазработка. При разработке блока с нуля, нужен исходный дизайн, продуктовые требования и изолированная среда для разработки. Удобно, когда это оказывается под рукой в одном интерфейсе.\nКод-ревью. Когда смотришь на чужую работу, нужно быстро увидеть перечень изменений; сверить результаты с продуктовыми требованиями и дизайном; проверить работоспособность всех кейсов использования блока.\nРефакторинг. При рефакторинге существующего блока нужно быстро увидеть весь блок и все его возможные состояния. Иногда состояний бывает много, и некоторые из них совсем не очевидные. После внесения изменений, важно проверить, что ничего не сломано.\n\r\nПри этом нужно отдавать себе отчёт в том, что положиться на инструмент можно только в том случае, если описанные нами тест-кейсы использования обеспечивают достаточное покрытие. Здесь работают те же принципы, как и при написании тестов.\n\r\nЕсли своевременно добавлять все необходимые тест-кейсы и использовать Makeup на всех этапах разработки, можно спать спокойно — никаких неожиданных неприятностей ваша вёрстка вам не принесет.\n\nКак подобрать тест-кейсы\r\nВ начале статьи я использовал термин «значимые состояния». Пора рассказать о том, как мы в работе выбираем значимые кейсы и как пытаемся обеспечить хорошее покрытие для вёрстки.\n\r\nМы пришли к выводу, что достаточно фиксировать 3 типа состояний.\n\n\nСостояния, описанные в дизайне.\r\nЕсли дизайнер подготовил макет, в котором нарисовал блок в 4 разных состояниях, нам нужно описать все эти состояния для Makeup.\nСостояния, которые вызвали баг в прошлом\r\nЕсли на проекте появляется баг, связанный с вёрсткой, его недостаточно просто починить. Хорошим тоном считается написать тест на этот баг. Мы в этом случае ещё сохраняем в Makeup кейс, в котором вопроизводился баг. Тогда при рефакторинге блока, когда разработчик проверит все состояния блока, он может быть уверен, что этот баг не воспроизводится.\nЭкстремальные состояния\r\nЭкстремальными состояниями мы называем те, в которых чаще всего ломается вёрстка: длинные тексты (которые могут ещё и не содержать пробелов), отсутствие элементов в блоке и другие.\n\nМожем ли мы перестать тестировать вёрстку руками\r\nЕсли нам важно точное соответствие исходному дизайну, к сожалению, нет. Но в наших силах сделать тестирование вёрстки комфортным, быстрым и надежным.\n\r\nПоэтому мы сделали для себя простой и удобный инструмент. По большому счету он просто выводит те данные, которые мы сами сохраняем в конфигурационных файлах блоков. Но несмотря на кажущуюся простоту, для нашей команды Makeup стал основой рабочего процесса разработки интерфейсов. С его помощью мы всегда знаем о самочувствии проекта и можем в любой момент увидеть полную картинку проекта с точки зрения вёрстки.\n\r\nА как тестируете вёрстку вы?\n\nСсылки\n\nРепозиторий\nСайт\nДемо\n "
]