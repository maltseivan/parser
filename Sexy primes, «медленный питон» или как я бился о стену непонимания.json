[
   "Sexy primes, «медленный питон» или как я бился о стену непонимания",
   "Многие разработчики, особенно принимающие активное участие в проектировании системы, наверняка сталкивались с подобной ситуацией: приходит коллега (разраб, проектлид или продажник не суть важно) с очередной идеей-фикс: давай перепишем все на java, scala и т.д. (любимое подставить).\n\r\nВот и мне в очередной раз «спустили» такую идею в немаленьком-таком legacy проекте. Не совсем переписать, не совсем все (ну в перспективе). В общем перейти с питона (а у нас там еще и тикль модульно присутствует) на scala. Речь пока шла о разработке новых модулей и сервисов, т.е. начинать с наименее привязанных к middle-level и front-nearby API's. Как я понял в перспективе возможно совсем.\n\r\nЧеловек — не разработчик, типа нач-проекта и немного продажник (для конкретного клиента) в одном лице.\n\r\nЯ не то, чтобы против. И скалу уважаю и по-своему люблю. Обычно я вообще открыт ко всему новому. Так, например, местами кроме тикля и питона у нас появляются сервисы или модули на других языках. Так, например, мы переехали с cvs на svn, а затем на git (а раньше, давно-давно, вообще MS-VSS был). Примеров на самом деле масса, объединяет их один момент — так решили или как минимум одобрили сами разработчики (коллективно ли, или была группа инициаторов — не суть важно). Да и дело в общем в аргументах за и против.\n\r\nПроблема в том, что иногда для аргументированной дискуссии «Developer vs. Anybody-Else» у последнего не дотягивает уровень знаний «материи» или просто невероятно сложно донести мысль — т.е. как-бы разговор на разных языках. И хорошо если это кто-нибудь типа software architect. Хуже, если имеем «беседу» например с чистым «продажником», огласившим например внезапные «требования» заказчика.\n\r\nНу почему никто не предписывает, например, плиточнику — каким шпателем ему работать (типа с зубцами 10мм клея же больше уйдет, давайте может все же 5мм. А то что там полы-стены кривущие никого не волнует). И шуруп теоретически тоже можно «закручивать» молотком, но для этого же есть отвертка, а позже был придуман шуруповёрт. Утрирую конечно, но иногда действительно напоминает такой вот абсурд.\n\r\nЭто я к тому, что инструмент в идеале должен выбирать сам разработчик или иметь в этом как минимум последнее слово — ему с этим инструментом работать или мучиться.\n\r\nНо что-то я отвлекся. В моей конкретной истории аргументов — за scala, у человека как всегда почти никаких. \r\nХотя я мог бы долго говорить про вещи, типа наличие разрабов, готовые наработки, отточенную и отлаженную систему и т.д. и т.п. Но зацепился за его «Питон очень медленный». В качестве примера он в меня кинул ссылкой на Interpreting a benchmark in C, Clojure, Python, Ruby, Scala and others — Stack Overflow, которую он даже до конца не прочитал (ибо там почти прямым текстом есть — не так плохо все с питоном).\n\r\nИмелось ввиду именно вот это (время указано в секундах):\n  Sexy primes up to:        10k      20k      30k      100k\n  ---------------------------------------------------------\n  Python2.7                1.49     5.20    11.00       119     \n  Scala2.9.2               0.93     1.41     2.73     20.84\n  Scala2.9.2 (optimized)   0.32     0.79     1.46     12.01\n\n\r\nРазговаривать с ним на уровне, про чисто техническую сторону, нет ни малейшего желания. Т.е. про выделение памяти/пул объектов, GC (у нас не чистый CPython, скорее похож на RPython или pypy с собственным Jit, MemMgr, GC), про всякий сахар, с которым человек, писавший бенчь, немного переборщил и т.д.\n\r\nМой ответ был «любят разрабатывать на питоне не за это» и «на нем так не пишут, по крайней мере критичный к скорости код». Я немного слукавил и естественно понимаю, что этот пример для benchmark искусственный, ну т.е. значит чисто померить скорость. Но и болячки, которые при таком тесте повыскакивают в CPython, мне тоже известны. \r\nПоэтому все же постарался на этом конкретном примере показать почему этот тест не целесообразен, ну или почему не совсем объективный что ли.\n\r\nНачал с того, что показал ему этот тест и результаты исполнения (помечены звездой) в PyMNg (что есть наша сборка), pypy2, pypy3 и python3 (который то же был по тем же понятным причинам медленный). Железо, конечно, другое, но порядок, думаю, примерно одинаков.\n  Sexy primes up to:        10k      20k      30k      100k\n  ---------------------------------------------------------\n  PyMNg                *   0.10        -        -      2.46\n  pypy2                *   0.13        -        -      5.44\n  pypy3                *   0.12        -        -      5.69\n  ---------------------------------------------------------\n  scala 2.10.4 (warmed up) *           -        -      6.57\n  scala 2.10.4 (cold)      *           -        -      7.11\n  ---------------------------------------------------------\n  Python3.4            *   1.41        -        -    117.69\n  ---------------------------------------------------------\n  Python2.7                1.49     5.20    11.00    119.00\n  Scala2.9.2               0.93     1.41     2.73     20.84\n  Scala2.9.2 (optimized)   0.32     0.79     1.46     12.01\n\r\nДальше можно было в принципе не продолжать, просто хотелось сделать попытку объяснить человеку, в чем он не прав, что выбор языка не оценивается по бенчмаркам типа «Hello, world» и т.д.\n\r\nИтак, задача — ищем «сексуальные» пары простых чисел на питоне. Много и быстро.\n\r\nДля тех кому разбор полетов не интересен, ссылка на скрипт на github, если есть желание поиграться.\n\r\nРезультаты исполнения каждого варианта под спойлером соответственно.\n100K для всех вариантов.\npypy3 sexy-primes-test.py 100K  org =  5.69000 s =   5690.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n mod1 =  2.45500 s =   2455.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n mod2 =  1.24300 s =   1243.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n org2 =  3.46800 s =   3468.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n  max =  0.03200 s =     32.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n orgm =  0.13000 s =    130.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nsiev1 =  0.01200 s =     12.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nsiev2 =  0.01000 s =     10.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nosie1 =  0.01200 s =     12.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nosie2 =  0.00200 s =      2.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\npython34 sexy-primes-test.py 100K  org = 120.75802 s = 120758.02 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n mod1 = 132.99282 s = 132992.82 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n mod2 = 76.65101 s =  76651.01 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n org2 = 53.42527 s =  53425.27 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n  max =  0.44004 s =    440.04 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n orgm =  0.39003 s =    390.03 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nsiev1 =  0.04000 s =     40.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nsiev2 =  0.04250 s =     42.50 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nosie1 =  0.04500 s =     45.00 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\nosie2 =  0.04250 s =     42.50 mils | 2447 sp: [5, 11], [7, 13], ... [99901, 99907], [99923, 99929]\n\n10M начиная с варианта max (остальные просто медленные на таком массиве).\npypy3 sexy-primes-test.py 10M max  max =  5.28500 s =   5285.00 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\n orgm = 12.65600 s =  12656.00 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nsiev1 =  0.51800 s =    518.00 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nsiev2 =  0.23200 s =    232.00 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nosie1 =  0.26800 s =    268.00 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nosie2 =  0.22700 s =    227.00 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\npython34 sexy-primes-test.py 10M max  max = 288.81855 s = 288818.55 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\n orgm = 691.96458 s = 691964.58 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nsiev1 =  4.02766 s =    4027.66 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nsiev2 =  4.05016 s =    4050.16 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nosie1 =  4.69519 s =    4695.19 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\nosie2 =  4.43018 s =    4430.18 mils | 117207 sp: [5, 11], [7, 13], ... [9999931, 9999937], [9999937, 9999943]\n\n100M начиная с варианта siev1 (по той же причине).\npypy3 sexy-primes-test.py 100M siev1siev1 =  7.39800 s =   7398.00 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\nsiev2 =  2.24500 s =   2245.00 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\nosie1 =  2.53500 s =   2535.00 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\nosie2 =  2.31000 s =   2310.00 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\npython34 sexy-primes-test.py 100M siev1siev1 = 41.87118 s =  41871.18 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\nsiev2 = 40.71163 s =  40711.63 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\nosie1 = 48.08692 s =  48086.92 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\nosie2 = 44.05426 s =  44054.26 mils | 879908 sp: [5, 11], [7, 13], ... [99999617, 99999623], [99999821, 99999827]\n\r\nКстати, такой разброс между CPython и PyPy и является часто одной из причин, почему люди переходят на PyPy, пишут собственные алокаторы, менеджеры памяти, GC, stackless и иже с ними, используют сторонние модули (например NumPy) и делают собственные сборки. Например, когда важна скорость исполнения и как здесь, имеем «агрессивное» использование пула объектов / множественные вызовы и т.д. Так же было когда-то давно и в нашем случае, когда мы переехали с чистого питона. Там еще было много чего, и тормозящий multithreding, и refcounting и т.д. Но сам переезд был обдуманным решением всей команды, а не «спущенной» сверху причудой. Если есть интерес и найду время, можно будет попробовать тиснуть про это статью.\n\r\nДля этой же конкретной «задачи» можно было бы написать собственный C-binding, использовать модули типа numpy и т.д. Я же попробовал убедить коллегу, что оно на коленке за незначительное время решается практически «алгоритмически», если знаешь, как питон тикает внутри.\n\r\nИтак, начнем доказывать человеку, что и питон умеет быстро «бегать», если все-таки решается поставленная задача, а не искусственный тест.\n\r\nОригинальный скрипт, немного измененный мной для читабельности и поддержки третьего питона, этот вариант у меня в скрипте-примере называется org. (Только, плз, не надо здесь про «xrange vs range» — я прекрасно представляю, в чем различие, и здесь конкретно оно не суть важно, тем более в 3-м питоне, кроме того, и итерация как-бы «завершенная»).\ndef is_prime(n):\n  return all((n % i > 0) for i in range(2, n))\n# def sexy_primes_below(n):\n#   return [[j-6, j] for j in range(9, n+1) if is_prime(j) and is_prime(j-6)]\ndef sexy_primes_below(n):\n  l = []\n  for j in range(9, n+1):\n    if is_prime(j-6) and is_prime(j):\n      l.append([j-6, j])\n  return l\n\r\nТ.к. даже на 10M имеем всего 100K sexy пар, изменение оригинальной primes_below на мой вариант с прямым циклом не сильно влияет на время исполнения, просто оно наглядней для изменений в последующих вариантах (например сито). Весь цимес в реализации is_prime, во всяком случае пока.\n\r\n1. Во-первых, использование такого «сахара» как в оригинале (тем более в «сборках» типа PyPy, ну или нашего PyMNg) не поощряется, ну или как минимум, как и в этом случае, больно бьет отдачей в виде снижения скорости. Перепишем это как вариант mod1\ndef is_prime(n):\n  i = 2\n  while True:\n    if not n % i:\n       return False\n    i += 1\n    if i >= n:\n       return True\n  return True\n\r\nУже быстрее, как минимум в PyPy. Но дело не в этом…\n\r\n2. Код стал сразу наглядней и видно, что его можно переписать как mod2 в половину быстрее, если не проверять четные номера (которые, кроме двойки, изначально не prime).\ndef is_prime(n):\n  if not n % 2:\n    return False\n  i = 3\n  while True:\n    if n % i == 0:\n       return False\n    i += 2\n    if i >= n:\n       return True\n  return True\n\r\nПоправим это в оригинале — org2 это то же самое что и mod2, но в одну строчку используя «сахар».\ndef is_prime(n):\n  return n % 2 and all(n % i for i in range(3, n, 2))\n\r\n3. Если проверять делители до значения квадратного корня (правильно было бы до округленного, но мы сделаем проще — это же просто тест), то все можно сделать еще намного быстрее, получим вариант max:\ndef is_prime(n):\n  if not n & 1:\n    return 0\n  i = 3\n  while 1:\n    if not n % i:\n       return 0\n    if i * i > n:\n       return 1\n    i += 2\n  return 1\nНамного быстрее, правда.\n\r\nОпять правим это в оригинале — orgm.\ndef is_prime(n):\n  #return ((n & 1) and all(n % i for i in range(3, int(math.sqrt(n))+1, 2)))\n  return ((n & 1) and all(n % i for i in range(3, int(n**0.5)+1, 2)))\n\r\nИ видим, что как минимум в PyPy оно опять выполняется медленнее (хотя частично, возможно, и из-за прямого подсчета «корня», который в range).\n\r\n4. Тут у коллеги загораются глаза, и он как в том мультфильме (по-моему, «Жадный богач») про скорняка и 7 шапок выдает: «А можешь еще быстрее?». Т.к. по памяти ограничения нет (не emdedded и т.д.) решил ему быстро переделать, используя «половинчатое» сито — half sieve, что есть подготовленный массив флажков по смещению для нечетных чисел, т.е. разделенных на 2. Тем более, что на питоне организовать такое сито на раз-два.\r\nНу и сразу видоизменяем sexy_primes_below, вызвав в нем генерацию сита ну и чтобы не править is_prime и не вызывать его в цикле, спрашиваем сразу sieve. \r\nПолучаем вариант siev1. \ndef primes_sieve(n):\n  \"\"\" temporary \"half\" mask sieve for primes < n (using bool) \"\"\"\n  sieve = [True] * (n//2)\n  for i in range(3, int(n**0.5)+1, 2):\n    if sieve[i//2]:\n      sieve[i*i//2::i] = [False] * ((n-i*i-1)//(2*i)+1)\n  return sieve\ndef sexy_primes_below(n):\n  l = []\n  sieve = primes_sieve(n+1)\n  #is_prime = lambda j: (j & 1) and sieve[int(j/2)]\n  for j in range(9, n+1):\n    i = j-6\n    #if (i & 1) and is_prime(i) and is_prime(j):\n    if (i & 1) and sieve[int(i/2)] and sieve[int(j/2)]:\n      l.append([i, j])\n  return l\nЭтот вариант настолько быстрый, что в PyPy, например, он на 100M выдает практически то же время, что оригинал на 100K. Т.е. проверяя в 2000 раз больше чисел и генерируя на несколько порядков больший список сексуально-простых пар.\n\r\nСразу переписал в вариант siev2, потому что вспомнил о несколько «туповатой» обработке bool в PyPy. Т.е. заменив булевы флажки на 0/1. Этот пример отрабатывает на 100M уже вдвое-трое быстрее оригинала на 100K!\n\r\n5. Варианты osiev1 и osiev2 написал, чтобы в дальнейшем можно было заменить сито для всех чисел, на множество более коротких, т.е. чтобы иметь возможность осуществлять поиск пар инкрементально или блочно. \n\r\nДля этого изменил сито смещений на прямое сито хранящее не флаги, а уже сами значения:\nsieve = [1, 1, 1, 0, 1, 1 ...]; # для 3, 5, 7, 9, 11, 13 ...\nosieve = [3, 5, 7, 0, 11, 13, ...]; # для 3, 5, 7, 9, 11, 13 ...\n\r\nВариант osiev1.\ndef primes_sieve(n):\n  \"\"\" temporary odd direct sieve for primes < n \"\"\"\n  sieve = list(range(3, n, 2))\n  l = len(sieve)\n  for i in sieve:\n    if i:\n      f = (i*i-3) // 2\n      if f >= l:\n        break\n      sieve[f::i] = [0] * -((f-l) // i)\n  return sieve\ndef sexy_primes_below(n):\n  l = []\n  sieve = primes_sieve(n+1)\n  #is_prime = lambda j: (j & 1) and sieve[int((j-2)/2)]\n  for j in range(9, n+1):\n    i = j-6\n    #if (i & 1) and is_prime(i) and is_prime(j):\n    if (i & 1) and sieve[int((i-2)/2)] and sieve[int((j-2)/2)]:\n      l.append([i, j])\n  return l\n\r\nНу и второй вариант osiev2 просто «чуть» быстрее, т.к. инициирует сито гораздо оптимальнее.\ndef primes_sieve(n):\n  \"\"\" temporary odd direct sieve for primes < n \"\"\"\n  #sieve = list(range(3, n, 2))\n  l = ((n-3)//2)\n  sieve = [-1] * l\n  for k in range(3, n, 2):\n    o = (k-3)//2\n    i = sieve[o]\n    if i == -1:\n      i = sieve[(k-3)//2] = k\n    if i:\n      f = (i*i-3) // 2\n      if f >= l:\n        break\n      sieve[f::i] = [0] * -((f-l) // i)\n  return sieve\n\r\nЭти два метода можно было переделать на итеративное сито (например, искать пары блочно по 10K или 100K). Это позволило бы значительно сэкономить память при подсчете. Например, если сейчас попробовать оба osieve варианта с 1G или 10G, мы практически гарантировано сразу получим MemoryError исключение (ну или вы богатый буратино — и у вас очень много памяти и 64-х битный питон.\n\r\nЯ не стал доделывать блочный способ (его нет в скрипте-примере, пусть это будет как бы «домашним заданием», если вдруг кто-нибудь захочет.), т.к. мой коллега уже раскаялся, в восхищении откланявшись, и я надеюсь как минимум не будет больше забивать голову мне (и команде) такой ерундой.\n\r\nА на исходных 100K время исполнения последнего уже невозможно было подсчитать — 0.00 mils (я подсчитал его, только увеличив количество итераций исполнения times до 10).\n\r\nВ чем я практически уверен — это то, что увеличить скорость еще на один порядок вряд ли удастся не только на scala, но и на чистом C. Если только снова алгоритмически…\n\r\nСам скрипт, буде кто собирается поэкспериментировать, можно спросить помощь, например, так:sexy-primes-test.py --help\n\r\nЕсли что, про простые числа довольно неплохо и очень подробно написано в wikihow.\n\r\nПо просьбам трудящихся добавил опрос… ",
   "  Только зарегистрированные пользователи могут участвовать в опросе. Войдите, пожалуйста. Python implementations, чем пользуетесь вы? \n            79.8%\n           CPython \n            237\n           \n            19.87%\n           PyPy \n            59\n           \n            3.37%\n           Stackless Python \n            10\n           \n            0.34%\n           RPython \n            1\n           \n            3.03%\n           IronPython \n            9\n           \n            2.36%\n           Jython \n            7\n           \n            2.02%\n           Собственная сборка \n            6\n           \n            8.42%\n           Другой вариант \n            25\n            \n       Проголосовали 297 пользователей. \n\n       Воздержались 308 пользователей. \n    "
]