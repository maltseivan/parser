[
   "Multi-page SPA на Питоне",
   "Мост между Python и React\n\r\nСова – это нано-фреймворк, который можно встроить в другие фреймворки.\r\nКартинка с sova.online, на котором запущено 3 http сервера:\nhttp://sova.online/ — просто Falcon\nhttp://sova.online:8000/ — просто Django\nhttp://sova.online:8001/ — просто Python (логин: 1, пароль: 1)\r\nТам же исходные коды и инструкция по установке. Там же нет рекламы.\n\n\n\r\nИдея делать сайты на Питоне с прорисовкой на React не нова. Есть замечательный фреймворк https://plot.ly/products/dash/, зачем еще что-то делать?\r\nОбъясняю: Сова не рассчитана на разработку сайтов. Это инструмент для замены толстых клиентов на приложения, работающие через браузер (десктопные приложения).\n\r\n — Что-ли веб-клиент?\r\n — Нет. Это не веб-клиент. Это приложение, работающее в браузере.\r\n — Не понимаю.\r\n — К сожалению, и многие разработчики не понимают.\n\r\nЯ как генеральный активно работал с несколькими интернет приложениями.\n\nОнлайн клиент банка Югра (банк закрыт).\r\nХорошее было приложение, но это был Java applet, т.е. толстый клиент, запускаемый из браузера. И банк Югра, и апплеты в прошлом.\n\nОнлайн клиент банка ВТБ-24 (банк закрыт).\r\nЯ гуманист, но поработав с этим чудом, стали появляться жестокие мысли типа: «Заставить разработчика зарегистрировать в нем 1000 платежек».\r\nПри этом как веб-клиент он прекрасен. Анимация, открывается на мобильнике. Вау! Круто!\r\nСпросил знакомого бухгалтера: как ты с ним работаешь?\r\nОна говорит: прекрасно! загружаю данные в 1с, в 1с работаю, результаты выгружаю обратно.\n\nОнлайн клиент сбербанка\r\nУдовлетворительный клиент, работать можно. Когда меня попросили его оценить, я поставил ему 3 бала из 5 и дал список замечаний. Это при моих 10 платежках в месяц. Те, кто делает 100 платежек в день, скорее всего, выгружают информацию.\n\r\nЗаполнение платежки. \n\r\nЗеленая область, занимающая 20% экрана – это меню. Оно не просто мешает (position: fixed), оно говорит о том, что разработчик не профессионал. Если я начал создавать платеж, на экране д.б. 3 кнопки: «Создать», «Сохранить как шаблон», «Отмена». Эти кнопки есть (почему-то внизу). Здесь не multi-page SPA: перейдешь по пункту меню, — данные в форме пропадут.\r\nТот, кто это делал, даже не поймет, в чем наезд: «Нормально сделано, все так делают, такая библиотека, люди ведь работают …». И он прав. Спрашивать надо с руководителя проекта, а для руководителя главное – это БД и слои в концептуальной модели. А формы – наймем мальчиков, они нарисуют. И ведь гордятся, наверное, этой халтурой.\n\nТорговые площадки (5 штук, 44 ФЗ)\r\nЭто действительно приложения (не веб-клиенты). Но контроллеры полей мне не нравятся.\r\nПримеры:\n\n\r\nВыровнено странно, ширина поля явно недостаточна, autoheight в поле ввода отсутствует.\n\r\nЕще пример. В поле «Дата публикации» нет шаблона дд.мм.гггг, календарь с ошибкой, пиктограмма календаря пугает:\n\n\r\nСписок на rts-tender: есть выделенная цветом текущая запись, стрелками можно двигаться по списку, но нет автоскроллинга (можно убежать за границу экрана), ни Enter, ни пробел не открывают ссылку, табулятор не привязан к текущей записи. Хотя открыть ссылку можно только мышкой, я оцениваю контрол со знаком плюс. Такого функционала (запомнить и подсветить текущий документ) мне не хватает в mail.ru \n\r\nВроде как мелочи. Но профессиональное приложение отличается от полупрофессионального именно мелочами. Конечному пользователю наплевать, какая у вас БД и сколько слоев в концептуальной модели. Он работает с экранными формами и у него 3 требования: функционально, удобно, быстро.\r\nК сожалению, выбор системы определяют айтишники и начальники, которые сами с системой не работали и работать не будут. Скорость они оценят, функциональность оценят так, как они это понимают, а на удобство им наплевать, главное, чтобы было красиво.\r\nПавел Валерьевич Дуров не изобретал ни соцсеть, ни мессенджер. Он сделал то, что нужно пользователям, удобно и красиво. И люди это оценили, в том числе и материально.\n\r\nСова – это инструмент для построения профессионального интерфейса.\r\nЧто это значит, на примере СЭД.\n\r\nЕсть СЭД, в ней 3 группы пользователей:\r\nНачальство\r\nСпециалисты, готовящие документы\r\nДелопроизводители.\n\r\nНачальники, они как дети. Им нужно, чтобы просто и красиво. В идеале 1 кнопка и 1 поле. И чтобы понтов побольше. Веб-клиент и, конечно, мобильный клиент, чтобы понты демонстрировать.\n\r\nСпециалисты. Веб-клиент, помесь соцсеть/почтовик. Не забывайте, что специалистов много и их надо обучать. Чем привычней будет для них среда, тем лучше. Мобильный клиент тоже пригодится, если служба безопасности разрешит.\n\r\nДелопроизводители. Вот здесь пригодится Сова. Делопроизводители – это системообразующая группа пользователей. Все остальные могут заболеть/уйти в отпуск/перестать пользоваться, — СЭД будет работать. Если остановится регистрация, встанет все.\r\nДелопроизводство – это конвейер, и здесь важно все, любая мелочь: шрифты, полутона, автоматическое заполнение, проверка значений, удобство ввода и т.д.\r\nСЭД «Дело». Кабинеты исполнителей сделаны на веб-клиенте, канцелярия – толстый клиент. Все прекрасно, но это будет работать, пока правительство не запретит Windows в госструктурах. Я люблю Win 7, но если бы правителем был я, it-рынок взбодрился новыми заказами, а MS остался в светлой памяти. Кстати, 6 декабря Антон Силуанов подписал директиву о переходе на отечественное ПО.\n\nSova.online\n\r\nКак Сова открывает форму.\r\nБез multi-page.\r\nЦентральным элементом Совы является компонент Document. Нажав ctrl-U на стартовой странице, вы увидите все, что нужно для создания объекта класса Document:\r\n — данные полей БД;\r\n — url формы для отображения;\r\n — dbAlias, unid — для работы с БД;\r\n — что-то там еще.\n\r\nВ некоторой степени Document – это аналог Redux-form. \r\nФорма загружается в виде JSON строки, затем бывший словарь становится объектом, имеющим style, className и массив (список) элементов. Массив будет вставлен в элемент с id=root в виде <div style className>…массив…</div>\r\nЭлемента массива — это объекты, описывающие теги <div>, <a>, <img>, <button>, или массив, или компоненты.\r\nЗа парсинг массива отвечает функция boxing. Если встретится элемент, содержащий массив, она рекурсивно вызовет себя.\r\nПуп земли, конечно, div.\r\nВ простейшем случае это строка: dict(div='Привет', className='h2')\r\nНо может быть и массив (массив массивов):\ndef style(**par):\n    return {'style': {**par}}\n\ndict( # словарь описывает стартовую страницу sova.online\n    style(position='relative'),\n    readOnly = 1,\n    div = [\n        dict( style(width=1000, margin='auto', paddingTop=20),\n            div=[\n                { 'div': subFormTop.panel() },\n                { 'div': [subFormLeft.panel(), subFormRight.panel()], 'className': 'row' },\n#                 { 'div': [subFormDown.panel()] },\n        ]),\n    ]\n)\n\r\nЗдесь 3 панели (каждая в отдельном файле: subFormTop.py и т.д.).\r\nsubFormTop.panel() возвращает массив для построения верхней панели.\r\nsubFormLeft.panel() и subFormRight.panel() объединены в строку ('className': 'row') и описывают левую и правую панели.\r\nsubFormDown.panel() закомментирована (не пригодилась).\n\r\nВозможно, покажется сложным. Но это Питон: все можно упростить.\r\nПример формы, из журнала «Отчеты». Функция labField(метка, имя_поля_БД) возвращает массив из двух словарей (строку таблицы): 1-й словарь – это {'div': метка}, второй {'field': [имя_поля_БД, 'tx']}.\ndiv = [\n\n    docTitle('Отчет'),\n\n    dict ( wl='40mm', className='cellbg-green', div=_table(\n        labField('Отчет', 'nodafd'),\n        labField('Запуск отчета', '_STARTINGTIME'),\n        labField('Окончание', '_ENDTIME'),\n        labField('Пользователь', 'CREATOR'),\n        \n        labField('Категория', 'REPORTCAT'),\n        labField('Название', 'REPORTNAME'),\n        labField('Заголовок', 'REPORTTITLE'),\n        labField('Начало периода', 'dt1'),\n        labField('Конец периода', 'dt2'),\n        labField('Начало периода 2', 'dt3'),\n        labField('Конец периода 2', 'dt4'),\n        labField('Журналы', 'LBYEARS'),\n        labField('Префиксы', 'GRGROUP'),\n        labField('Формула отбора', 'QUERYMAIN'),\n        labField('Комментарий', 'NOTES'),\n    )),\n\n    sent(),\n]\n\n\n\n\r\nПримеры из sova/api/forms/home/top.py (стартовая на sova.online):\n\r\nпитоновский словарь\r\n{'a': 'React v16', 'href': 'https://reactjs.org'}\r\nПородит понятную React компоненту\n<a href={'https://reactjs.org'}>React v16</a>\n\r\nImg поумнее стандартного – в пропсах можно задать href и target:\n\r\nПитон:\r\ndict(img='image?react.ico', style={'width':16}, href='https://reactjs.org')\n\r\nФрагмент парсера, преобразующего массив объектов в компоненты (boxing.js):\nif ( td.img ) { // td – это элемент массива\n\tlet img = <img src={td.img} прочие_пропсы/>;\n\treturn td.href ?\n\t\t<a href={td.href} key={i} target={td.target}>{img}</a>\n\t\t:\n\t\timg;\n}\n\n\r\nНаберите в поисковике «react component library». Результат предсказуем, — очень много. Но все это изобилие предназначено веб-сайтам, не приложениям:\r\nSmart-textarea – пожалуй, единственный контрол, который меня устроил.\r\nReact-select –упростил и переделал выпадающий список\r\nData-picker/calendar – не нашел ничего подходящего. Написал свой, взяв за образец встроенный в G.Chrome.\r\nUpload / Download – ничего подходящего, написал свой.\n\r\nImho: у веб-сайтов грустное будущее. Подавляющее большинство пользователей в ближайшем будущем перестанет пользоваться браузерами (или уже перестало). Телефон срастется с планшетом, а 1 тире 10 приложений полностью обеспечат потребности.\r\nЯ уже дважды сталкивался с программистами, которые не знают, как правильно написать адрес e-mail. Зачем им помнить то, чем они не пользуются. Мир меняется.\n\r\nВ Сове контроллеры не идеальные, но они разрабатывались в расчете на оператора, а не веб-пользователя.\r\nКак пример форма «Отметка о передаче». Достаточно универсальная форма, используется там, где есть начальник. Красным на скриншоте обведены поля, управляющие скрытием. Дополнительные резолюции открываются автоматически по мере заполнения, если в резолютивной части несколько поручений разным группам исполнителям с разными сроками. Два срока на группу: 1-й срок 1-му исполнителю, 2-й срок соисполнителям.\n\n\r\nПотрогать форму можно ЗДЕСЬ\n\r\nКонтроллер – это компонента React связанная с полем БД.\r\nПодробное описание контроллеров с возможностью проверить их работу есть на Sova.online.\r\nОбратите внимание на типы rtf и json. Rtf отображается как текст, но, если в тексте встретится конструкция {_ {объект} _}, Сова выполнит для этой конструкции json.parse и добавит результат в форму. Поле с типом json должно хранить описание массива элементов разметки: [{элем1}, {элем2}, …]. json.parse выполняется перед рендерингом.\r\nПоля с такими типами позволяют хранить разметку в БД или в файлах. Полезно при формировании отчетов и написании документации.\n\r\nСписок контроллеров для всех типов полей (controllers.js):\nexport const controller = prop => {\n\tswitch (prop.type) { //тип поля\n\t\tcase 'chb':\treturn <Checkbox {...prop}/>;\n\t\tcase 'lbse': // listbox single enable (разрешить значения не из списка)\n\t\tcase 'lbme': // listbox multivalue enable\n// lbse/lbme - это текстовое поле с кнопкой, открывающей список\n\n\t\tcase 'tx':\treturn <Text {...prop}/>; // smart-textarea\n\t\tcase 'lbsd':  // listbox single disables (запретить значения не из списка)\n\t\tcase 'lbmd':\treturn <ListBox {...prop}/>;\n\t\tcase 'dt':\treturn (prop.readOnly ?\n\t\t\t\t\t<Text {...prop} xValue={Util.dtRus(prop.xValue)} />\n\t\t\t\t\t:\n\t\t\t\t\t<Datepicker {...prop}/>);\n\t\tcase 'fd':\treturn <ForDisplayOnly {...prop}/>;\n\t\tcase 'table':\n\t\tcase 'gr':\treturn <Table {...prop}/>;\n\t\tcase 'rtf':\treturn <RTF {...prop}/>;\n\t\tcase 'json':\treturn <JsonArea {...prop}/>;\n\t\tcase 'list':\treturn <List {...prop}/>;\n\t\tcase 'view':\treturn <View {...prop}/>;\n\t\tdefault:\n\t\t\tconsole.warn('Неизвестный тип поля', prop.xName, prop.type);\n\t\t\treturn <Text {...prop}/>;\n\t};\n};\n\n\r\nДля работы приложения необходим механизм манипуляции контроллерами.\r\nВ сове все контроллеры документа хранятся в переменной документа\r\nthis.register\r\nИспользовать refs я не рискнул из-за слухов, что редаксофилы его отменят.\r\nКонтроллер может иметь следующие интерфейсы:\r\ngetValue(param)\r\nsetValue(value, param)\r\nsetFocus()\r\nchangeDropList()\n\r\nДля того, чтобы обратиться к нужному полю, есть методы документа\r\ngetField(fieldName, param)\r\nsetField(fieldName, value, param)\r\nchangeDropList(fieldName, param)\r\nsetFocus(fieldName)\r\nДля полей типа FileShow есть метод fileShow['FILES1_'].hasAtt(), где FILES1_ имя области с файлами. Возвращает true, если есть вложения. В отметке о передаче таких областей 2.\n\r\nКонтроллеры могут генерировать событие «recalc». Если для данного поля прописан обработчик, он выполнится. Обработчики находятся в подгружаемых js-файлах.\r\nПример и несколько упрощенное описание:\r\nЕсть форма «Отметка о передаче» (o.py). В ней прописан подгружаемый файл o.js\r\nВ o.js прописаны обработчики\nrecalc: {\n    PROJECTO: doc => doc.forceUpdate(),\n    WHOPRJ2: doc => doc.forceUpdate(),\n    WHOPRJ3: doc => doc.forceUpdate(),\n    … другие обработчики\n}\r\n, а также прописаны условия скрытия (project, op, prj1, prj2…prj5 – это свойство «name» в описании div'ов):\nhide: {\n        project: doc => !doc.getField('projectO'), // скрыть, если поле PROJECTO пустое\n        op: doc => doc.getField('projectO'), // скрыть, если поле PROJECTO не пустое\n        prj1: doc => !doc.getField('projectO'),\n        prj2: doc => !doc.getField('projectO'),\n        prj3: doc => !doc.getField('projectO') || (!doc.getField('whoPrj2') && !doc.getField('whoPrj3')),\n        prj4: doc => !doc.getField('projectO') || (!doc.getField('whoPrj3') && !doc.getField('whoPrj4')),\n        prj5: doc => !doc.getField('projectO') || (!doc.getField('whoPrj4') && !doc.getField('whoPrj5')),\n      },\n\r\nКак это работает: поле PROJECTO – это чекбокс, при изменении значения контроллер генерирует событие recalc, документ вызывает обработчик recalc.PROJECTO(this).\r\nОбработчик просто вызывает forceUpdate() – перерисовать документ.\r\nПри перерисовке проверяется, есть ли у компоненты в пропсах name, есть ли для этого name функция hide[props.name] и не вернет ли она true.\r\nprj3: doc => !doc.getField('projectO') || (!doc.getField('whoPrj2') && !doc.getField('whoPrj3'))\r\nСкрывать третью резолюцию (область с props.name === 'prj3'), если чекбокс 'projectO' в состоянии OFF или в полях резолюций 2 и 3 исполнители не введены (оба поля 'whoPrj2' и 'whoPrj3' пустые).\r\nИмя поля при вызове функций регистронезависимо.\r\nWHOPRJ2 – это поле со списком, при выборе значения контроллер также сгенерит событие recalc, которое также вызовет перерисовку. Выбрав исполнителя во второй резолюции, вы тем самым откроете третью.\n\r\nВ подгружаемых js-файлах можно:\r\n — управлять скрытием;\r\n — управлять только чтением;\r\n — реагировать на изменения полей;\r\n — выполнять команды кнопок;\r\n — делать валидацию полей и формы перед сохранением;\n\r\nПодгружаемый файл для формы 'fo':\n\nwindow.sovaActions = window.sovaActions || {}; \nwindow.sovaActions.fo = { // fo – имя формы на нижнем регистре\n\n    recalc: { // обработчик вызывается при изменении значений чекбоксов и полей со списком\n        PROJECTO: doc => doc.forceUpdate(),\n    },\n\n    hide: {   // скрывать именованную область, если true\n        project: doc => !doc.getField('projectO'),\n    },\n\n    readOnly: {   // только чтение для именованной области, если true\n        who: doc => doc.getField('SENTFROMDB'),\n    },\n\n    validate: { // проверка полей и формы перед отправкой на сервер\n        who: doc => doc.getField('who') ? '' : 'Не заполнено поле \"Кому направлено\"',\n\n        form: doc => new Promise( (yes, no) => {\n            let disableAutoOrder = false;\n            for (let i = 1; i <= 5; i++) {\n                let val = doc.getField('RESPRJ' + i);\n                disableAutoOrder  |= /за моей подписью/.test(val);\n            }\n            disableAutoOrder && doc.setField('AUTOORDER', '');\n            yes();\n        }),\n    },\n\n    cmd: { // выполнение команд кнопок\n        logoff: doc => { window.location.href = '/logoff' },\n    },\n\n}\n\r\nВалидация полей – функция, возвращает пусто, если все ОК, или сообщение о том, что не так. Сова установит фокус на невалидное поле.\r\nВалидация формы – промис. В примере проверок нет (всегда вызывается yes), просто что-то выполняется перед отправкой на сервер.\r\nВ redux-form валидация сделана через trow – дикость какая-то.\n\nДля тех, кто не знаком с промисами, пример простейшего:\nconst confirmDlg = msg => new Promise((ok, cancel) => confirm(msg) ? ok('Нажата кнопка ОК') : cancel('Нажата кнопка cancel'));\nconfirmDlg('Самый простой промис')\n    .then( s => console.log(s))\n    .catch( s => console.log(s));\n\r\nКласс Document имеет несколько предопределенных команд, которые можно использовать в кнопках:\n\r\nedit: перейти в режим редактирования формы\r\n save: сохранить форму\r\n close: закрыть форму\r\n saveClose: сохранить и закрыть форму\n\r\nprn: распечатать форму с выбором шаблона для печати\r\n docOpen: открыть документ\r\n dbOpen: открыть журнал\r\n xopen: открыть url\r\n newDoc: создать новый документ с нужной формой\n\r\nВ Redux-form api побогаче, — в Сове только необходимое.\n\nMulti-page.\n\r\nКласс Document создает объект (форму), который встраивается в элемент <div id=\"root\"></div>.\r\nНазовем его «корневой документ». Если в корневой документ добавить элемент\r\n<div style={{position: 'absolute', zIndex: 999}}/>, в него точно также можно вставить другой объект Document.\r\nКак быть с подгружаемыми обработчиками команд? Все просто: каждая форма имеет свой обработчик (свой js), и корневой документ должен загрузить те из них, которые могут потребоваться.\r\nПример для стартовой страницы sova.online (home.py)\r\nФорма home.py, чтобы продемонстрировать многостраничность, открывает документы с формами «rkckg», «outlet», «outlet.gru», «o».\r\nЧтобы все формы корректно работали, необходимо прописать в home.py скрипты для этих форм:\njavaScriptUrl = ['jsv?api/forms/rkckg/rkckg.js',\n                 'jsv?api/forms/outlet_gru/outlet_gru.js',\n                 'jsv?api/forms/outlet/outlet.js',\n                 'jsv?api/forms/o/o.js',\n                 'jsv?api/forms/home/home.js']\n\r\nПоскольку при вызове любой функции обработчика первым параметром передается ссылка на документ, действия будут выполнены с нужным документом.\n\r\nООП и никаких чудес.\n\r\nReact – не React\r\nЯ уже описывал форму «report». Она открывается из менеджера отчетов (стрелка «React») и описывает параметры сбора отчета.\n\r\nСами отчеты (стрелка «не React») хранятся в подчиненных документах с формой «rreport» в виде html вложений. Мы занимались разработкой отчетов, когда React не было, форма «rreport» получилась простая (20 строк html и 15 строк просто-js), зачем менять то, что 8 лет работает.\n\nОткрыть менеджер отчетов.\n\r\nФорма «rreport» состоит из 4-х кнопок и iframe. Сова перед открытием документа заменяет в айфрейме src=\"\" на строку с url для скачивания html-вложения, остальное делает браузер.\r\nС кнопками EXCEL / WORD аналогично: вставляем в нужное место кнопки url для скачивания с именем файла «report.html.xls» или «report.html.doc» и соответствующим mime-type. Остальное делают Excel/Word («эти умные животные отлично понимают все, что от них хотят» ). \r\nИз do_get.py:\n\ndownloadUrl = '/download/' + fn + '?' + '&'.join([d.db.alias, d.unid, idbl, fsName, fzip, ctype, flen])\nexcel = '/download/%s.xls?%s' % (fn, '&'.join([d.db.alias, d.unid, idbl, fsName, fzip, 'application/x-excel', flen])) \nword = '/download/%s.doc?%s' % (fn, '&'.join([d.db.alias, d.unid, idbl, fsName, fzip, 'application/msword', flen]))\n\nhtml = html.replace('src=\"\"', 'src=\"%s\"' % downloadUrl).replace('openExcel', excel).replace('openWord', word)\n\r\nПри открытии html в Excel/Word отличия от браузера есть, но небольшие. Да и статья не об этом.\n\nДелаем форму с нуля.\n\r\nИсходные данные:\r\nЕсть 3 функции\r\ndef snd(*msg, cat='snd'):\r\ndef err(*msg, cat='all'):\r\ndef dbg(*msg, cat='snd'):\r\n, которые более-менее равномерно распределены по всему коду и пишут в лог-файл сообщения об ошибках и прочую хрень.\r\nФормат сообщений передается в logging.Formatter в виде:\r\n'%(asctime)s %(levelname)s [%(name)s] %(message)s'\r\nФайл заполняется сообщениями \r\n…\r\n02.09.2018 17:50:07 DEBUG [http-server] addr ('127.0.0.1', 49964), «GET /arm HTTP/1.1» 200 –\r\n02.09.2018 17:54:07 INFO [Free space] Вложения сохраняются в \".\\DB\\files\" Свободно 68557 Mb\r\n02.09.2018 17:58:07 ERROR [do_get.py] getScript: [Errno 2] No such file or directory: 'sova/api/forms/o/oo.js'\r\n…\r\nДата-время, затем уровень, затем в квадратных скобках категория внутри уровня, затем сообщение.\n\r\nЗадача:\r\nСделать страницу для просмотра лог-файла. Что типа\n\n\r\nНазовем форму «lm», формироваться она будет функцией page в модуле api/forms/lm.py\ndef page(dbAlias, mode, userName, multiPage):\n    \n    return dict(\n        style(background='url(/image?bg51.jpg)', backgroundSize='100% 100%'),\n        div=[\n            dict(\n                style(width='200px', float='left', background='rgba(210,218,203, 0.5)', padding='0 5px'),\n                div=[\n                    _field('type', 'list', ['Весь журнал|all', 'Ошибки|err', 'Сообщения|info', 'Отладка|debug'],\n                           saveAlias=1,\n                           **style(margin='10px auto', width=170, height=110)\n                    ),\n    \n                    _field('cat', 'list', 'TYPE_ALIAS|||api.get?loadDropList&logger|keys_{FIELD}',\n                           listItemClassName='repName',\n                           listItemSelClassName='repNameSel',\n                           **style(height='calc(100vh - 133px)', overflow='auto')\n                    )\n                ],\n            ),\n    \n            _field('msg', 'fd',\n                   br=1,\n                   **style(overflow='auto', height='100vh', font='bold 12px Courier', background='rgba(255,255,255, 0.8)')\n            ),\n        ]\n    )\n\r\nВ левой части 2 поля, оба с типом «list»: type и cat (тип сообщения и категория).\r\nВ правой одно поле msg с типом fd (forDisplayOnly).\r\nТипы сообщений прописаны в описании поля (['Весь журнал|all', 'Ошибки|err',...),\r\nкатегории вытягиваются по xhr из глобального словаря с вызовом хитрого url:\r\napi.get?loadDropList&logger|keys_err вернет в json-формате массив (список) категорий из глобального словаря. Что-то типа well('logger', 'keys_err').\r\nСообщения формируются при открытии документа функцией queryOpen в lm.py\ndef queryOpen(d, mode, ground):\n    logParser()\n    ls = well('logger_all', 'A L L')\n    s = '\\n'.join(reversed(ls))\n    d.msg = s\n    d.type_alias = 'all'\r\nlogParser считывает и парсит log-файл. Результаты раскладывает в несколько массивов и сохраняет их в глобальном словаре. Ничего интересного: 2 простейших re и цикл по итератору.\r\nФункции для работы с глобальным словарем:\r\ntoWell(o, key1, [key2]) — сохранить в глобальном словаре объект «o»\r\nwell(key1, [key2]) — взять из глобального словаря объект по ключу (по двум ключам).\r\nДля первой прорисовки этого достаточно. Чтобы можно было отобразить сообщения нужного типа и нужной категории, необходимо сделать подгружаемый js.\r\nВ lm.py добавляем строку\r\njavaScriptUrl = 'jsv?api/forms/lm/lm.js'\r\nи создаем lm.js:\nwindow.sovaActions = window.sovaActions || {};\nwindow.sovaActions.lm = { // обработчики формы \"lm\"\n    init: doc => doc.changeDropList('CAT'),\n    recalc: {\n        TYPE: (doc, label, alias) => {\n            doc.changeDropList('CAT');\n            getLogData(doc, alias + '|A L L');\n        },\n        CAT: (doc, label) => getLogData(doc, doc.getField('type_alias') + '|' + label),\n    },\n};\n\n// *** *** ***\n\nlet getLogData = (doc, keys) => {\n    fetch('api.get?getLogData&' + keys, {method: 'get', credentials: 'include'})\n        .then( response => response.text() )\n        .then( txt => doc.setField('msg', txt) )\n        .catch( err => doc.setField('msg', err.message) );\n};\n\r\ngetLogData вытягивает с сервера сообщения нужного типа и нужной категории:\ndef getLogData(par, un):\n    lg, _, cat = par.partition('|')\n    msg = well('logger_' + lg, cat)\n    return 200, 'text/html; charset=UTF-8', '\\n'.join(reversed(msg))\n\n\r\nНасладиться формой можно ЗДЕСЬ.\r\nИзначально логгирование было сделано на основе стандартного модуля logging\r\nс использованием logging.FileHandler, .addHandler и прочих getLogger и setFormatter.\r\nКак учили. Но при этом глючило. Можете кидаться камнями, но когда я выкинул logging и стал просто писать в файл, код стал короче, понятней и глюки исчезли.\n\r\nВ комплекте есть самописный многопоточный wsgi сервер с Digest авторизацией. Это не для сайтов. Зачем он вообще понадобился?\r\nУ заказчика 40 юр. лиц, в большинстве случаев с системой работают 1-2-3 человека. Хранить данные в интернете запрещено. У всех win 7. Требуется простота установки и конфигурации.\r\nРешение: с помощью cx-Freeze и Inno Setup делаем инсталлятор, запускаем его на компьютере самого ответственного и получаем мини-http сервер для локальной сети, стартующий как сервис Windows. Ничего лишнего. Использовать встроенный в Питон wsgiref.simple_server или wsgi_Werkzeug нельзя, т.к. они однопоточные: пока один запрос не отработает, другие будут ждать.\r\nВряд ли я кого удивлю, сообщив, что встроенный в Django WSGIServer/0.2 CPython/3.5.3 в разы быстрее самописного питоновского. Только это не имеет значения, — формы и справочники кэшируются на клиенте, по локальной сети очень быстро передаются только данные БД.\r\nЕсть еще одна причина: десктопное приложение имеет доступ к ресурсам компьютера (ЭЦП, файлы, сканер...). Чтобы из браузера получить аналогичный доступ надо или писать плагин, или повесить в сервисах маленький http-сервер, который может и с главным сервером снюхаться, и нужные действия на локале выполнит.\n\r\nСова не использует инструменты фреймворков для работы с БД. В директории dbToolkit нечто похожее по структуре на MongoDB (или на Lotus Notes) на SQLite3:\r\nКласс Book – db (в терминологии MongoDB и Lotus Notes)\r\nКласс DocumentCollection – коллекция документов из Book\r\nКласс Document – документ (объект, содержащий любое количество полей).\n\nУстановка: \r\nСкачать с sova.online архив owl.zip\n\r\nВ архиве каталог owl, из которого можно запустить Сову из django, falcon или без фреймворков.\n\r\nСкачать, распаковать.\r\nУстановить Python3 (3.5+)\n\r\n1. owl – без фреймворков. Внимание! Логин: 1, пароль: 1\n\r\nLinux:\r\ncd ./owl\r\npython3 wsgi_sova.py\n\r\nили в отдельном окне\r\nscreen -Udm python3 wsgi_server.py\n\r\nWindows:\r\ncd ./owl\r\nwsgi_sova.py\n\r\n2. Django\n\r\nLinux:\r\nУстановить django: \r\npip3 install django \r\ncd ./owl\r\npython3 manage.py runserver\n\r\nили в отдельном окне\r\nscreen -Udm python3 manage.py runserver 127.0.0.1:8000\n\r\nWindows:\r\nУстановить django: \r\npip install django\r\ncd ./owl\r\nmanage.py runserver\n\r\n3. falcon\n\r\nLinux:\r\npip3 install falcon\r\ncd ./owl\r\npython3 wsgi_sova.py falconApp:api 8001 log_falcon/falcon\n\r\nWindows:\r\npip install falcon\r\ncd ./owl\r\nwsgi_sova.py falconApp:api 8001 log_falcon/falcon\n\r\n*********************\n\r\n — название у статьи странное, сам то понял, что такое «Multipage SPA»?\r\n — обычный маркетинговый ход\r\n — а почему без Redux? Все используют Redux\r\n — слово «редюсер» мне не нравится\r\n — а серьезно? СombineReducers на любом уровне иерархии… Это так красиво\r\n — это multipage, детка. Обработчики команд должны быть внутри формы, а не как рога у оленя\r\n — зачем ты вообще статью написал?\r\n — пиарюсь "
]