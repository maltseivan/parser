[
   "Как справиться с PAGELATCH при высоко-параллельных INSERT-нагрузках",
   "По материалам статьи: «Resolving PAGELATCH Contention on Highly Concurrent INSERT Workloads».Авторы: Thomas Kejser, Lindsey Allen, Arvind Rao и Michael ThomassyПри участии и с рецензиями: Mike Ruthruff, Lubor Kollar, Prem Mehra, Burzin Patel, Michael Thomassy, Mark Souza, Sanjay Mishra, Peter Scharlock, Stuart Ozer, Kun Cheng и Howard YinВведениеНедавно, мы проводили лабораторные испытания в Microsoft Enterprise Engineering Center, при которых использовалась большая рабочая нагрузка, характерная для OLTP систем. Целью этой лабораторной работы было определить, что случится при увеличении числа процессоров с 64 до 128, при обслуживании Microsoft SQL Server интенсивной рабочей нагрузки (примечание: эта конфигурация была ориентирована на релиз Microsoft SQL Server 2008 R2). Рабочая нагрузка представляла собой хорошо распараллеленные операции вставки, направляемые в несколько больших таблиц.Рабочая нагрузка масштабировалась до 128 процессорных ядер, но в статистике ожиданий было очень много кратких блокировок PAGELATCH_UP и PAGELATCH_EX. Средняя продолжительность ожидания была десятки миллисекунд, и таких ожиданий было очень много. Такое их количество оказалось для нас неожиданностью, ожидалось, что продолжительность не будет превышать несколько миллисекунд.В этой технической заметке вначале будет описано, как диагностировать подобную проблему и как для разрешения подобной проблемы использовать секционирование таблиц.Диагностика проблемыКогда в sys.dm_os_wait_stats наблюдается большое число PAGELATCH, с помощью sys.dm_os_waiting_tasks можно определить сессию и ресурс, который задача ожидает, например, с помощью этого сценария:SELECT session_id, wait_type, resource_description \nFROM sys.dm_os_waiting_tasks\nWHERE wait_type LIKE 'PAGELATCH%'Пример результата:                                                                 В столбце resource_description указаны местоположения страниц, к которым ожидают доступ сессии, местоположение представлено в таком формате: <database_id>:<file_id>:<page_id>Опираясь на значения в столбце resource_description, можно составить довольно сложный сценарий, который предоставит выборку всех попавших в список ожидания страниц:SELECT wt.session_id, wt.wait_type, wt.wait_duration_ms    \n, s.name AS schema_name \n, o.name AS object_name \n, i.name AS index_name  \nFROM sys.dm_os_buffer_descriptors bd \nJOIN (      \nSELECT *          \n, CHARINDEX(':', resource_description) AS file_index       \n, CHARINDEX(':', resource_description\n, CHARINDEX(':', resource_description)) AS page_index          \n, resource_description AS rd \nFROM sys.dm_os_waiting_tasks wt    \nWHERE wait_type LIKE 'PAGELATCH%'        \n) AS wt     \nON bd.database_id = SUBSTRING(wt.rd, 0, wt.file_index)     \nAND bd.file_id = SUBSTRING(wt.rd, wt.file_index, wt.page_index)  \nAND bd.page_id = SUBSTRING(wt.rd, wt.page_index, LEN(wt.rd))\nJOIN sys.allocation_units au ON bd.allocation_unit_id = au.allocation_unit_id\nJOIN sys.partitions p ON au.container_id = p.partition_id\nJOIN sys.indexes i ON  p.index_id = i.index_id AND p.object_id = i.object_id\nJOIN sys.objects o ON i.object_id = o.object_id \nJOIN sys.schemas s ON o.schema_id = s.schema_idСценарий показал, что ожидаемые страницы относятся к кластеризованному индексу, определённому первичным ключом таблицы с представленной ниже структурой:CREATE TABLE HeavyInsert (  \n  ID INT PRIMARY KEY CLUSTERED   \n  , col1 VARCHAR(50) \n) ON [PRIMARY] Что происходит, почему возникает очередь ожиданий к страницам данных индекса – всё это будет рассмотрено в этой технической заметке.Основная информацияЧтобы определить, что происходит с нашей большой OLTP-нагрузкой, важно понимать, как SQL Server выполняет вставку в индекс новой строки. При необходимости вставки в индекс новой строки, SQL Server будет следовать следующему алгоритму внесения изменений:В журнале транзакций создаётся запись о том, что строка изменилась.Осуществляется поиск в В-дереве местонахождения той страницы, куда должна будет попасть новая запись.Осуществляется наложение на эту страницу краткой блокировки PAGELATCH_EX, которая призвана воспрепятствовать изменениям из других потоков.Осуществляется добавление строки на страницу и, если это необходимо, осуществляется пометка этой страницы как «грязной».Осуществляется снятие краткой блокировки со страницы.  В итоге, страница должна будет быть сброшена на диск процессом контрольной точкой или отложенной записи. Если же все вставки строк направлены на ту же самую страницу, можно наблюдать рост очереди к этой странице. Даже притом, что краткая блокировка весьма непродолжительна, она может стать причиной конкуренции при высоком параллелизме рабочей нагрузки. У нашего клиента, первый и единственный столбец в индексе являлся монотонно возрастающим ключом. Из-за этого, каждая новая вставка шла на ту же самую страницу в конце В-дерева, пока эта страница не была заполнена. Рабочие нагрузки, которые используют в качестве первичного ключа IDENTITY или другие столбцы с последовательно увеличивающимися значениями, также могут столкнуться с подобной проблемой, если распараллеливание достаточно высоко.РешениеВсегда, когда несколько потоков получают синхронный доступ к одному и тому же ресурсу, может проявиться описанная выше проблема. Стандартное решение состоит в том, чтобы  создать больше ресурсов конкурентного доступа. В нашем случае, таким конкурентным ресурсом является последняя страница В-дерева.Одним из способов снизить конкуренцию за одну страницу состоит в том, чтобы выбрать в качестве первого столбца индекса другой, не увеличивающийся монотонно столбец. Однако, для нашего клиента это потребовало бы внесения изменений на прикладном уровне в клиентских системах. Мы должны были найти другое решение, которое могло бы ограничиться только изменениями в базе данных.Помните, что местом конкуренции является одна страница в В-дерева, и конкуренция была бы меньше, если бы было возможно использовать для этого несколько В-деревьев, и в то же время работать только с одной таблицей. К счастью, такая возможность есть, это: Секционированные таблицы и индексы. Таблица может быть секционирована таким способом, чтобы новые строки размещались в нескольких  секциях. Сначала нужно создать функцию и схему секционирования:CREATE PARTITION FUNCTION pf_hash (INT) AS RANGE LEFT FOR VALUES (0,1,2) \nCREATE PARTITION SCHEME ps_hash AS PARTITION pf_hash ALL TO ([PRIMARY])Представленный выше пример использует четыре секции. Число необходимых секций зависит от числа активных процессов, выполняющих операции INSERT в описанную выше таблицу. Есть некоторая сложность в секционировании таблицы с помощью хэш-столбца, например, в том что всякий раз, когда происходит выборка строк из таблицы, будут затронуты все секции. Это означает, что придётся обращаться более чем к одному В-дереву, т.е. не будет отброшенных оптимизатором за ненадобностью ненужные секций. Будет дополнительная нагрузка на процессоры и некоторое увеличение времени ожиданий процессоров, что побуждает минимизировать число планируемых секций (их должно быть минимальное количество, при котором не наблюдается PAGELATCH). В рассматриваемом нами случае, в системе нашего клиента имелось достаточно много резерва в утилизации процессоров, так что было вполне возможно допустить небольшую потерю времени для инструкций SELECT, и при этом увеличить до необходимых объёмов норму инструкций INSERT.Ещё одной сложностью является то, что нужен дополнительный столбец, по которому будет выполняться секционирование, т.е. на основании значения которого будут распределяться вставки по четырем секциям. Такого столбца изначально в сценарии Microsoft Enterprise Engineering Center не было. Однако, его достаточно просто было создать. Для этого использовался тот факта, что столбец ID монотонно увеличивается с приращением равным единице, и здесь легко применима довольно простая хеш-функция:CREATE TABLE HeavyInsert_Hash(  \n  ID INT NOT NULL  \n  , col1 VARCHAR(50)  \n  , HashID AS ID % 4 PERSISTED NOT NULL)С помощью столбца HashID, вставки в четыре секции будут выполняться циклически. Создаём кластеризованный индекс следующим образом:CREATE UNIQUE CLUSTERED INDEX CIX_Hash \nON HeavyInsert_Hash (ID, HashID) ON ps_hash(HashID)Используя новую схему таблицы с секционированием вместо первоначального варианта таблицы, мы сумели избавиться от очередей PAGELATCH и повысить скорость вставки. Этого удалось достичь за счёт балансировки вставки между несколькими секциями и высокого параллелизма. Вставка происходит в несколько страниц, и каждая страница размещается в своей собственной структуре В-дерева. Для нашего клиента удалось повысить производительность вставки на 15 процентов, и справится с большой очередью PAGELATCH к горячей странице индекса одной таблицы. Но при этом удалось также оставить достаточно большой резерв циклов процессоров, что оставило возможность сделать аналогичную оптимизацию для другой таблицы, тоже с высокой нормой вставки.Строго говоря, суть этой уловки в оптимизации логической схемы первичного ключа таблицы. Однако, потому что ключ просто стал длиннее на величину хеш-функции относительно изначального ключа, дубликатов для столбца ID удалось избежать.Уникальные индексы по единственному столбцу таблицы зачастую становятся причиной проблем с очередями PAGELATCH. Но даже если эту проблему удастся устранить, у таблицы может оказаться другой, некластеризованный индекс, который будет подвержен той же самой проблеме. Как правило, проблема наблюдается для уникальных ключей на единственном столбце, где каждая вставка попадает на одну и ту же страницу. Если и у других таблиц индексы подвержены проблеме с PAGELATCH, можно применить эту же уловку с секционированием к индексам таких таблиц, используя такой же ключ с хэшем в качестве первичного ключа.Не всегда возможно внести изменения в приложение, особенно, если оно является плодом усилий третьих фирм. Но если изменение запросов возможно, становится доступной их оптимизация за счёт добавления к ним условий фильтрации по предикатам первичного ключа. Пример: Чтобы отбросить ненужные секции, можно внести следующие изменения в сценарий: SELECT * FROM HeavyInsert_Hash \n      WHERE ID = 42Который после изменений будет выглядеть так:SELECT * FROM HeavyInsert_Hash \n      WHERE ID = 42 AND HashID  = 42 % 4Исключение оптимизатором ненужных секций по значению хэша не будет вам ничего стоить, если только не считать большой платой за это увеличение на один байт каждой строки кластеризованного индекса.Дополнительные материалыSQL Server Performance Tuning: Resolving Last Page Insert ContentionResolve last-page insert PAGELATCH_EX contention in SQL Server "
]