[
   "Решение головоломки Галакуб на Питоне",
   "На новый год купил племяннику головоломку Галакуб. Задача собрать из разных деталей куб размером 4х4х4. Суммарный объём деталей, как раз, 4х4х4. Прежде, чем дарить надо было собрать головоломку. Красивое симметричное решение нашлось достаточно быстро. Но стало интересно единственное это решение или нет. Интуиция подсказывала, что единственное, но хотелось проверить.\n\n\r\nЯ решил по-быстрому запилить скрипт для перебора всех вариантов. В идеале нужно было успеть до новогодней речи Путина. Ситуация усугублялась тем, что код писался на Макбуке моих родителей. Поставить на него какие-то библиотеки — это задача покруче, чем написать саму программу.\n\r\nКод получился на удивление красивый и понятный. Его удобно объяснять. Может быть, текст будет полезен, например, изучающим Питон.\n\r\nВсе детальки представлялись в виде тензоров 4х4х4.\ndef zero_vector():\n    return [0] * 4\n\n\ndef zero_matrix():\n    return [zero_vector() for _ in xrange(4)]\n\n\ndef zero_tensor():\n    return [zero_matrix() for _ in xrange(4)]\n\n\r\nКубик кодируется буквой «Q», уголок — буквой «J», загогулина — «Z».\n\ndef parse_tensor(data):\n    tensor = zero_tensor()\n    lines = data.splitlines()\n    for z in xrange(2):\n        for y in xrange(4):\n            line = lines[z * 5 + 1 + y]\n            for x in xrange(4):\n                if line[x] == '*':\n                    tensor[z][y][x] = 1\n    return tensor\n    \n\nJ = parse_tensor(\"\"\"\n***.\n*...\n....\n....\n\n***.\n*...\n....\n....\n\n\"\"\")\n\nQ = parse_tensor(\"\"\"\n**..\n**..\n....\n....\n\n**..\n**..\n....\n....\n\n\"\"\")\n\nZ = parse_tensor(\"\"\"\n*...\n*...\n....\n....\n\n*...\n***.\n.**.\n....\n\n\"\"\")\n\n>>> J\n[[[1, 1, 1, 0], [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n [[1, 1, 1, 0], [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]\n\r\nЧтобы удобнее смотреть на тензоры (а смотреть на них нужно будет много и внимательно), была написана функция show_tensor обратная функции parse_tensor:\ndef show_tensor(tensor):\n    for y in xrange(4):\n        for z in xrange(4):\n            for x in xrange(4):\n                value = tensor[z][y][x]\n                print {\n                    1: '*',\n                    0: '.'\n                }[value],\n            print ' ',\n        print\n\n\ndef show_tensors(tensors):\n    for tensor in tensors:\n        show_tensor(tensor)\n        print\n\n\n>>> show_tensors([J, Q, Z])\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * . .   * * . .   . . . .   . . . .  \n* * . .   * * . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* . . .   * . . .   . . . .   . . . .  \n* . . .   * * * .   . . . .   . . . .  \n. . . .   . * * .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\r\nДальше нужно было сгенерировать все возможные положения для каждой детальки. Вращение по оси Х и Y на 90 градусов сводятся к перестановке осей.\n\ndef rotate_by_x(tensor):\n    rotated = zero_tensor()\n    for z in xrange(4):\n        for y in xrange(4):\n            for x in xrange(4):\n                rotated[z][y][x] = tensor[y][-z - 1][x]\n    return rotated\n    \n\ndef rotate_by_y(tensor):\n    rotated = zero_tensor()\n    for z in xrange(4):\n        for y in xrange(4):\n            for x in xrange(4):\n                rotated[z][y][x] = tensor[x][y][-z - 1]\n    return rotated\n\r\nЧтобы не дублировать циклы можно завести функцию transform_tensor, она пригодится ещё не раз:\ndef transform_tensor(tensor, function):\n    transformed = zero_tensor()\n    for z in xrange(4):\n        for y in xrange(4):\n            for x in xrange(4):\n                transformed[z][y][x] = function(tensor, x, y, z)\n    return transformed\n\n\ndef rotate_by_x(tensor):\n    return transform_tensor(tensor, lambda _, x, y, z: _[y][-z - 1][x])\n\n\ndef rotate_by_y(tensor):\n    return transform_tensor(tensor, lambda _, x, y, z: _[x][y][-z - 1])\n\r\nПосмотрим что получается:\ndef apply_transformation(tensor, transformation, times=1):\n    for _ in xrange(times):\n        tensor = transformation(tensor)\n    return tensor\n\n\ndef show_transformation(tensor, transformation):\n    show_tensors([\n        tensor,\n        transformation(tensor),\n        apply_transformation(tensor, transformation, times=2),\n        apply_transformation(tensor, transformation, times=3),\n        apply_transformation(tensor, transformation, times=4),\n    ])\n\n\n>>> show_transformation(J, rotate_by_x)\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   . . . .   * . . .   * * * .  \n. . . .   . . . .   * . . .   * * * .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   * . . .   * . . .  \n. . . .   . . . .   * * * .   * * * .  \n\n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n* * * .   * . . .   . . . .   . . . .  \n* * * .   * . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .\n\n>>> show_transformation(J, rotate_by_y)\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   * * . .   * * . .   * * . .  \n. . . .   . . . .   . . . .   * * . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   . . . .   . * * *   . * * *  \n. . . .   . . . .   . . . *   . . . *  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . * *   . . * *   . . * *   . . . .  \n. . * *   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\r\nВращение по оси Z удивительным образом можно получить вращением по оси X и Y. Только вращать надо в разные стороны, поэтому в rotate_by_y придётся ввести направление:\ndef rotate_by_y(tensor, direction=1):\n    if direction == 1:\n        function = lambda _, x, y, z: _[x][y][-z - 1]\n    else:\n        function = lambda _, x, y, z: _[-x - 1][y][z]\n    return transform_tensor(tensor, function)\n\n\ndef rotate_by_z(tensor):\n    return rotate_by_y(rotate_by_x(rotate_by_y(tensor, direction=-1)))\n\r\nПосмотрим, что получается:\n\n>>> show_transformation(J, rotate_by_z)\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . * *   . . * *   . . . .   . . . .  \n. . . *   . . . *   . . . .   . . . .  \n. . . *   . . . *   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . *   . . . *   . . . .   . . . .  \n. * * *   . * * *   . . . .   . . . .  \n\n. . . .   . . . .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n* * . .   * * . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .\n\r\nХорошо, кроме вращений есть ещё сдвиги. Имея функцию transform_tensor, сделать сдвиг с переносом очень просто:\ndef shift_by_x(tensor):\n    return transform_tensor(tensor, lambda _, x, y, z: _[z][y][(x + 1) % 4])\n\r\nПроблема только в том, что возникают несуществующие детали:\n>>> show_transformation(J, shift_by_x)\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * . *   * * . *   . . . .   . . . .  \n. . . *   . . . *   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* . * *   * . * *   . . . .   . . . .  \n. . * .   . . * .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. * * *   . * * *   . . . .   . . . .  \n. * . .   . * . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\r\nПоэтому решение придётся усложнить. Будем делать сдвиг, только если есть пустое место под перенос. Нужно добавить код для вычисления проекции тензора и проверки матрицы на пустоту:\ndef project_tensor(tensor, function):\n    projection = zero_matrix()\n    for i in xrange(4):\n        for j in xrange(4):\n            projection[i][j] = function(tensor, i, j)\n    return projection\n\n\ndef project_by_x(tensor):\n    return project_tensor(tensor, lambda _, z, y: tensor[z][y][0])\n\n\ndef project_by_y(tensor):\n    return project_tensor(tensor, lambda _, z, x: tensor[z][0][x])\n\n\ndef project_by_z(tensor):\n    return project_tensor(tensor, lambda _, y, x: tensor[0][y][x])\n\n\ndef is_empty_matrix(matrix):\n    for i in xrange(4):\n        for j in xrange(4):\n            if matrix[i][j]:\n                return False\n    return True\n\r\nТеперь сдвиг будет выглядеть так:\ndef shift_by_x(tensor):\n    if is_empty_matrix(project_by_x(tensor)):\n        return transform_tensor(tensor, lambda _, x, y, z: _[z][y][(x + 1) % 4])\n    return tensor\n\r\nТеперь если деталь упирается в границу, ничего не происходит:\n>>> show_transformation(J, shift_by_x)\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * * .   * * * .   . . . .   . . . .  \n* . . .   * . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .\n\r\nПравда не получится сгенерировать все возможные детали. Нужно добавить ещё направление и каждый раз делать сдвиги в обе стороны. Финальная версия есть на Гитхабе. \n\r\nХорошо, чтобы получить все возможные положения для каждой детали, нужно перебрать все углы поворота и все размеры сдвигов:\ndef generate_permutations(tensor):\n    for x_rotations in xrange(4):\n        for y_rotations in xrange(4):\n            for z_rotations in xrange(4):\n                for x_shifts in xrange(3):\n                    for x_direction in (-1, 1):\n                        for y_shifts in xrange(3):\n                            for y_direction in (-1, 1):\n                                for z_shifts in xrange(3):\n                                    for z_direction in (-1, 1):\n                                        permutation = apply_transformation(tensor, rotate_by_x, times=x_rotations)\n                                        permutation = apply_transformation(permutation, rotate_by_y, times=y_rotations)\n                                        permutation = apply_transformation(permutation, rotate_by_z, times=z_rotations)\n                                        permutation = apply_transformation(permutation, shift_by_x, direction=x_direction, times=x_shifts)\n                                        permutation = apply_transformation(permutation, shift_by_y, direction=y_direction, times=y_shifts)\n                                        permutation = apply_transformation(permutation, shift_by_z, direction=z_direction, times=z_shifts)\n                                        yield permutation\n\r\nМного комбинаций дублируется. Например, кубик вращать бесполезно, новых комбинаций это не добавляет:\n>>> Qs = list(generate_permutations(Q))\n>>> show_tensors(sample(Qs, 10))\n* * . .   * * . .   . . . .   . . . .  \n* * . .   * * . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n* * . .   * * . .   . . . .   . . . .  \n* * . .   * * . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. * * .   . * * .   . . . .   . . . .  \n. * * .   . * * .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. * * .   . * * .   . . . .   . . . .  \n. * * .   . * * .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. * * .   . * * .   . . . .   . . . .  \n. * * .   . * * .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\r\nЧтобы оставить только уникальные варианты, надо определить функцию, которая ставит в соответствие тензору число. Для этого можно представить тензор 4х4х4 в виде двоичного 64-битного числа:\ndef hash_tensor(tensor):\n    hash = 0\n    index = 0\n    for z in xrange(4):\n        for y in xrange(4):\n            for x in xrange(4):\n                index += 1\n                hash += tensor[z][y][x] * 2 ** index\n    return hash\n\r\nТеперь оставить уникальные комбинации просто:\ndef unique_tensors(tensors):\n    hashes = set()\n    for tensor in tensors:\n        hash = hash_tensor(tensor)\n        if hash not in hashes:\n            yield tensor\n        hashes.add(hash)\n\n\nZs = list(unique_tensors(generate_permutations(Z)))\nJs = list(unique_tensors(generate_permutations(J)))\nQs = list(unique_tensors(generate_permutations(Q)))\n\n\n>>> show_tensors(sample(Qs, 10))\n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   * * . .   * * . .  \n. . . .   . . . .   * * . .   * * . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . * * .   . * * .  \n. . . .   . . . .   . * * .   . * * .  \n\n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. * * .   . * * .   . . . .   . . . .  \n. * * .   . * * .   . . . .   . . . .  \n\n. . . .   . . . .   . * * .   . * * .  \n. . . .   . . . .   . * * .   . * * .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. . . .   . . . .   . . * *   . . * *  \n. . . .   . . . .   . . * *   . . * *  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n\n. * * .   . * * .   . . . .   . . . .  \n. * * .   . * * .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .  \n. . . .   . . . .   . . . .   . . . .\n\r\nЗа счёт того, что кубик небольшой, вариантов не так много:\n>>> len(Zs), len(Js), len(Qs)\n(288, 432, 27)\n\r\nСамый примитивный поиск решения мог бы выглядеть так:\ndef solve(Zs, Js, Qs):\n    for Z1 in Zs:\n        for Z2 in Zs:\n            for Z3 in Zs:\n                for J1 in Js:\n                    for J2 in Js:\n                        for J3 in Js:\n                            for Q1 in Qs:\n                                for Q2 in Qs:\n                                    if not tensors_intersect(Z1, Z2, Z3, J1, J2, J3, Q1, Q2):\n                                        yield Z1, Z2, Z3, J1, J2, J3, Q1, Q2\n\r\nНо это слишком тупо, нужно будет перебрать 28834323272 вариантов. Выход есть. После того как, например, зафиксирована первая деталь, нужно игнорировать все варианты, в которых вторая деталь пересекается с первой. В решении в лоб это не так. Даже если Z1 и Z2 пересекаются, все остальные 6 подциклов отработают. Решение получше будет выглядеть так:\ndef solve_(path, done, hashes, todo):\n    for hash in hashes:\n        if not tensors_intersect(done, hash):\n            if todo:\n                for solution in solve_(path + [hash], union_hashes(done, hash), todo[0], todo[1:]):\n                    yield solution\n            else:\n                yield path + [hash]\n\n\ndef solve(Zs, Js, Qs):\n    done = zero_tensor()\n    todo = [Z_hashes] * 3 + [J_hashes] * 3 + [Q_hashes] * 2\n    for solution in solve_([], done, todo[0], todo[1:]):\n        yield solution\n\r\nНо есть ещё один нюанс. Функция tensors_intersect выглядит так:\ndef tensors_intersect(a, b):\n    for z in xrange(4):\n        for y in xrange(4):\n            for x in xrange(4):\n\t        if a[z][y][x] and b[z][y][x]:\n\t\t    return True\n    return False\n\r\nОна работает долго. Выход опять есть. Функция, которая ставит тензору в соответствие число, выбрана очень удачно. Если оперировать этими числами, а не тензорами проверка на пересечение будет выглядеть так:\ndef tensor_hashes_intersect(a, b):\n    return a & b\n\r\nПоиск решений немного изменится:\ndef union_tensor_hashes(a, b):\n    return a | b\n\n\ndef unhash_tensor(hash):\n    tensor = zero_tensor()\n    index = 0\n    for z in xrange(4):\n        for y in xrange(4):\n            for x in xrange(4):\n                index += 1\n                if hash & 2 ** index:\n                    tensor[z][y][x] = 1\n    return tensor\n\n\ndef solve_(path, done, hashes, todo):\n    for hash in hashes:\n        if not tensor_hashes_intersect(done, hash):\n            if todo:\n                for solution in solve_(path + [hash], union_tensor_hashes(done, hash), todo[0], todo[1:]):\n                    yield solution\n            else:\n                yield path + [hash]\n\n\ndef solve(Zs, Js, Qs):\n    Z_hashes = [hash_tensor(_) for _ in Zs]\n    J_hashes = [hash_tensor(_) for _ in Js]\n    Q_hashes = [hash_tensor(_) for _ in Qs]\n    done = hash_tensor(zero_tensor())\n    todo = [Z_hashes] * 3 + [J_hashes] * 3 + [Q_hashes] * 2\n    for solution in solve_([], done, todo[0], todo[1:]):\n        yield [unhash_tensor(_) for _ in solution]\n\r\nЗапускаем:\nsolutions = list(solve(Zs, Js, Qs))\n\r\nЖдём шесть часов и получаем 576 решений. Естественно много дублирующихся. Оставляем только уникальные и получаем 8 вариантов:\n>>> show_tensors(unique_tensors(solution_tensor(_) for _ in solutions))\n# # # *   # * * *   * * . .   * * . .  \n# # # *   # * * *   # * . .   # * . .  \n. . # #   . . * *   # * * *   # * * *  \n. . # #   . . # #   # # # #   # # * *  \n\n. . # #   . . # #   # # # *   # # # *  \n. . # #   . . * *   # * * *   # * * *  \n# # # #   # * * *   # * . .   * * . .  \n# # * *   # * * *   # * . .   * * . .  \n\n# # . .   # # . .   # # # #   * * # #  \n# # . .   * * . .   * * * #   * * * #  \n* # # #   * * * #   . . * #   . . * #  \n* # # #   * * * #   . . * *   . . * *  \n\n* * # #   * * * #   . . * #   . . * *  \n# # # #   * * * #   . . * #   . . * *  \n# # . .   * * . .   * * * #   * * * #  \n# # . .   # # . .   * # # #   * # # #  \n\n* * . .   # * . .   # * * *   # # * *  \n* * . .   # * . .   # * * *   # # # #  \n# * * *   # * * *   . . * *   . . # #  \n# # # *   # # # *   . . # #   . . # #  \n\n# # * *   # # # #   . . # #   . . # #  \n# * * *   # * * *   . . * *   . . # #  \n# * . .   # * . .   # * * *   # # # *  \n* * . .   * * . .   # * * *   # # # *  \n\n* # # #   * # # #   # # . .   # # . .  \n* * * #   * * * #   * * . .   # # . .  \n. . * *   . . * #   * * * #   # # # #  \n. . * *   . . * #   * * * #   * * # #  \n\n. . * *   . . * *   * * * #   * # # #  \n. . * #   . . * #   * * * #   * # # #  \n* * * #   * * * #   * * . .   # # . .  \n* * # #   # # # #   # # . .   # # . .  \n\r\nК сожалению это все возможные вращения того самого варианта, которое было найдено вручную. То есть у Галакуба есть только одно решение. "
]