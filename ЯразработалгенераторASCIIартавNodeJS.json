[
   "Я разработал генератор ASCII-арта в Node JS",
   "В этой статье вы увидите, как сделать генератор ASCII-арта из изображения.Результат:но сначалачто такое ASCII-арт?ASCII-арт — это метод графического дизайна, который использует компьютеры для презентации и он состоит из изображений, собранных вместе из 95 печатных символов, определенных стандартом ASCII от 1963 года, и ASCII-совместимых наборов символов с проприетарными расширенными символами.Необходимые условияДля данного проекта мне хочется применить свои знания JS, поэтому я буду использовать:Node jsSharpreadline-syncnpm i sharp readline-syncЭтапы программы:Когда я думал об ASCII-арте, то представлял, что он создается с помощью какого-то алгоритма детекции краев. Как же я ошибался — для создания ASCII-арта из изображения вам потребуется:превратить изображение в черно-белое;изменить размер изображения;заменить все черно-белые пиксели на символы, определяющие яркость и темноту/тень.Итак, давайте приступим. Сначала я создам файл package.json, сделав следующее:npm initКак только я получу свой пакет, то создам index.js файл, где будет находиться мой код.Когда это будет сделано, я импортирую все зависимости, необходимые для этого проекта, следующим образом:const sharp = require(\"sharp\");\nconst readlineSync = require(\"readline-sync\");\nconst fs = require(\"fs\");Тогда давайте сначала запросим у пользователя изображение, которое он хочет преобразовать.Получение пользовательского вводаДля этого я создам функцию loadFileFromPath и в ней буду получать данные от пользователя следующим образом:var filePath = readlineSync.question(\"What's the file path \");Зачем нам нужен readlineSync?Вероятно, вам интересно, что представляет собой пакет readlineSync. Он позволяет нам вводить данные в консоль синхронно; поскольку JS-узел является асинхронным, код продолжает выполняться, поэтому мы используем пакет для того, чтобы дождаться ввода данных пользователем.Далее я проверю, корректен ли путь или нет, с помощью операторов try/catch, как здесь:try {\n    const file = await sharp(filePath);\n    return file;\n  } catch (error) {\n    console.error(error);\n  }и вся функция выглядит следующим образом:const loadFileFromPath = async () => {\n  var filePath = readlineSync.question(\"What's the file path \");\n  try {\n    const file = await sharp(filePath);\n    return file;\n  } catch (error) {\n    console.error(error);\n  }\n};Преобразование в черно-белоеДля этого я сначала создам функцию convertToGrayscale с таким параметром пути, как здесь:const convertToGrayscale = async (path) => {\n  // code\n};В этой функции я загружу изображение, изменю его цветовые значения на черно-белые и, наконец, верну черно-белый результат.const convertToGrayscale = async (path) => {\n const img = await path; \n const bw = await img.gamma().greyscale();\n return bw;\n};Изменение размера изображенияДля этого я сначала создам функцию resizeImg с параметрами bw и newWidth = 100 следующим образом:const resizeImg = async (bw, newWidth = 100) => {\n  //code\n};Затем я буду ждать ч/б изображение и ожидать результат переменной blackAndWhite, потом получу метаданные для доступа к свойствам размеров.const resizeImg = async (bw, newWidth = 100) => {\n  const blackAndWhite = await bw;\n  const size = await blackAndWhite.metadata();\n};далее вычисляем пропорции изображения, для этого просто делим ширину на высоту и получаем необходимое соотношение. Затем мы рассчитываем нашу новую высоту:const ratio = size.width / size.height;\nnewHeight = parseInt(newWidth * ratio);Потом мы окончательно изменяем размер изображения и возвращаем его в таком виде:const resized = await blackAndWhite.resize(newWidth, newHeight, {\n    fit: \"outside\",\n  });\nreturn resized;Вся функция должна выглядеть следующим образом:const resizeImg = async (bw, newWidth = 100) => {\n  const blackAndWhite = await bw;\n  const size = await blackAndWhite.metadata();\n  const ratio = size.width / size.height;\n  newHeight = parseInt(newWidth * ratio);\n  const resized = await blackAndWhite.resize(newWidth, newHeight, {\n    fit: \"outside\",\n  });\n\n  return resized;\n};Преобразование пикселей в ASCII-символы Для этого я сначала создам функцию pixelToAscii с параметром img следующим образом:const pixelToAscii = async (img) => {\n //code\n};Затем я создам переменную для хранения img с ключевым словом await. Потом получу массив пикселей изображения и сохраню его в переменной pixels.var newImg = await img;\nconst pixels = await newImg.raw().toBuffer();\n};Дальше создам переменную characters, которая будет содержать пустую строку. Затем я пройдусь по каждому пикселю из массива и введу ASCII-символ в созданную ранее строку:characters = \"\";\npixels.forEach((pixel) => {\n    characters = characters + ASCII_CHARS[Math.floor(pixel * interval)];\n  });Вы можете заметить две глобальные переменные, которые еще не упоминались:intervalASCII_CHARSЯ объясню вам, что они из себя представляют:ASCII_CHARS — это переменная, в которой хранятся все ASCII-символы:ASCII_CHARS = \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \".split(\n  \"\"\n);interval — это ascii, который должен быть присвоен цвету (интенсивность).charLength = ASCII_CHARS.length;\ninterval = charLength / 256;Теперь мы знаем, что это за переменные, давайте вернемся к функции, сейчас она должна выглядеть следующим образом:const pixelToAscii = async (img) => {\n  var newImg = await img;\n  const pixels = await newImg.raw().toBuffer();\n  characters = \"\";\n  pixels.forEach((pixel) => {\n    characters = characters + ASCII_CHARS[Math.floor(pixel * interval)];\n  });\n  return characters;\n};Теперь все шаги сделаны, давайте создадим ядро приложения:Главная функцияДля этого я сначала создам функцию main с параметрами newWidth = 100 следующим образом:const main = async (newWidth = 100) => {\n  //code\n};В этой функции я создам функцию с названием: *newImgData, которая будет равна всем тем функциям, которые мы создали ранее, вложенным следующим образом:const main = async (newWidth = 100) => {\n  const newImgData = await pixelToAscii(\n    resizeImg(convertToGrayscale(loadFileFromPath()))\n  );\n};Затем я выясню длину моих символов и создам пустую переменную с именем ASCII следующим образом:const pixels = newImgData.length;\nlet ASCII = \"\";Потом переберу список пикселей:for (i = 0; i < pixels; i += newWidth) {\n    let line = newImgData.split(\"\").slice(i, i + newWidth);\n    ASCII = ASCII + \"\\n\" + line;\n  }По существу, я делаю разбиение на строки. Получаю размер newWidth, нарезаю массив как строку этой newWidth и затем добавляю символ \\n для перехода к следующей строке.Экспорт в текстовый файлИ, наконец, в той же функции для сохранения текста в файл я сделал следующее:setTimeout(() => {\n    fs.writeFile(\"output.txt\", ASCII, () => {\n      console.log(\"done\");\n    });\n  }, 5000);В результате мы получили ASCII-арт генератор из изображения! И, конечно же, не забудьте про main() для первого вызова функции.Законченный код должен выглядеть следующим образом:const sharp = require(\"sharp\");\nconst readlineSync = require(\"readline-sync\");\nconst fs = require(\"fs\");\n\nASCII_CHARS = \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \".split(\n  \"\"\n);\ncharLength = ASCII_CHARS.length;\ninterval = charLength / 256;\nvar newHeight = null;\nconst main = async (newWidth = 100) => {\n  const newImgData = await pixelToAscii(\n    resizeImg(convertToGrayscale(loadFileFromPath()))\n  );\n  const pixels = newImgData.length;\n  let ASCII = \"\";\n  for (i = 0; i < pixels; i += newWidth) {\n    let line = newImgData.split(\"\").slice(i, i + newWidth);\n    ASCII = ASCII + \"\\n\" + line;\n  }\n\n  setTimeout(() => {\n    fs.writeFile(\"output.txt\", ASCII, () => {\n      console.log(\"done\");\n    });\n  }, 5000);\n};\n\nconst convertToGrayscale = async (path) => {\n  const img = await path;\n  const bw = await img.gamma().greyscale();\n  return bw;\n};\n\nconst resizeImg = async (bw, newWidth = 100) => {\n  const blackAndWhite = await bw;\n  const size = await blackAndWhite.metadata();\n  const ratio = size.width / size.height;\n  newHeight = parseInt(newWidth * ratio);\n  const resized = await blackAndWhite.resize(newWidth, newHeight, {\n    fit: \"outside\",\n  });\n\n  return resized;\n};\n\nconst pixelToAscii = async (img) => {\n  var newImg = await img;\n  const pixels = await newImg.raw().toBuffer();\n  characters = \"\";\n  pixels.forEach((pixel) => {\n    characters = characters + ASCII_CHARS[Math.floor(pixel * interval)];\n  });\n  return characters;\n};\n\nconst loadFileFromPath = async () => {\n  var filePath = readlineSync.question(\"What's the file path \");\n  try {\n    const file = await sharp(filePath);\n    return file;\n  } catch (error) {\n    console.error(error);\n  }\n};\nmain();Чему я научился в ходе работы над этим проектом?Этот проект был очень интересным. Я впервые обнаружил, что можно вложить функции, также выяснил, как работает ASCII-арт, узнал об асинхронной проблеме js-узла для пользовательского ввода и о том, как ее решить, и, наконец, как сделать некоторые простые манипуляции с изображениями.Анимации на сайте давно перестали быть каким-то ноу-хау. Это неотъемлемая часть любого интерфейса. Скоро в OTUS пройдет открытый урок, на котором разберем основы, необходимые для работы с анимацией, и создадим анимированный приветственный экран приложения. Регистрация по ссылке. "
]