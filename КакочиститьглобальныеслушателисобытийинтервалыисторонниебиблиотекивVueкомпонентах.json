[
   "Как очистить глобальные слушатели событий, интервалы и сторонние библиотеки в Vue-компонентах",
   "В идеале Vue-компоненты представляют собой самодостаточные части пользовательского интерфейса без каких-либо заметных побочных эффектов для объектов за пределами области действия данного элемента. Но, к сожалению, это не всегда возможно. Например, иногда нам нужно связать глобальных слушателей событий, использовать setInterval или инициализировать определенную стороннюю библиотеку внутри компонента.// Vue 3\nexport default defineComponent({\n  name: 'SomeComponent',\n  setup() {\n    // Global event listener\n    document.body.addEventListener('click', () => {\n      // do something expensive ...\n    }, { capture: true });\n    \n    // Interval\n    setInterval(() => {\n      // do something expensive ...\n    }, 2000);\n    \n    // Third-party library\n    let flatpickrElement = ref(null);\n    onMounted(() => {\n      flatpickr(flatpickrElement.value);\n    });\n    \n    // ...\n  },\n});\n\n// Vue 2\nexport default {\n  name: 'SomeComponent',\n  created() {\n    // Global event listener\n    document.body.addEventListener('click', () => {\n      // do something expensive ...\n    }, { capture: true });\n    \n    // Interval\n    setInterval(() => {\n      // do something expensive ...\n    }, 2000);\n  },\n  mounted() {\n    // Third-party library\n    flatpickr(this.$refs.flatpickrElement);\n  },\n};В подобных случаях компоненты должны очищаться после их уничтожения. Если этого не сделать, могут произойти самые разнообразные неприятности — от сбоев в работе наших приложений до утечек памяти.Удаление глобальных слушателей событий, очистка интервалов и сторонних библиотекДавайте обновим наш демонстрационный пример, добавив хуки для очистки глобальных побочных эффектов, вызываемых нашим компонентом.// Vue 3\nexport default defineComponent({\n  name: 'SomeComponent',\n  setup() {\n    // Global event listener\n    let options = { capture: true };\n    let callback = () => {\n      // do something expensive ...\n    };\n    document.body.addEventListener('click', callback, options);\n    onUnmounted(() => document.body.removeEventListener('click', callback, options));\n    \n    // Interval\n    let intervalId = setInterval(() => {\n      // do something expensive ...\n    }, 2000);\n    onUnmounted(() => clearInterval(intervalId));\n    \n    // Third-party library\n    let flatpickrElement = ref(null);\n    let flatpickrInstance;\n    onMounted(() => {\n      flatpickrInstance = flatpickr(flatpickrElement.value);\n    });\n    onUnmounted(() => flatpickrInstance.destroy());\n    \n    // ...\n  },\n});\n\n// Vue 2\nexport default {\n  name: 'SomeComponent',\n  created() {\n    // Global event listener\n    let options = { capture: true };\n    let callback = () => {\n      // do something expensive ...\n    };\n    document.body.addEventListener('click', callback, options);\n    this.$once('hook:beforeDestroy', () => document.body.removeEventListener('click', callback, options));\n    \n    // Interval\n    let intervalId = setInterval(() => {\n      // do something expensive ...\n    }, 2000);\n    this.$once('hook:beforeDestroy', () => clearInterval(intervalId));\n    \n    // Third-party library\n    let flatpickrInstance;\n    this.$once('hook:mounted', () => {\n      flatpickrInstance = flatpickr(this.$refs.flatpickrElement);\n    });\n    this.$once('hook:beforeDestroy', () => flatpickrInstance.destroy());\n  },\n};Каждый раз, когда наш компонент уничтожается, вызываются соответствующие хуки, а глобальные побочные эффекты очищаются. Таким образом, нам не нужно беспокоиться об утечке памяти или о том, что глобальные слушатели событий будут накапливаться с каждым новым созданным нами инстансом компонента.Хуки beforeDestroy и onUnmounted в тестах @vue/test-utilsОдин из моих коллег обнаружил, что при тестировании компонентов с помощью замечательного пакета @vue/test-utils хуки beforeDestroy и onUnmounted не вызываются после теста! Так и задумано, хотя я не предполагал этого. В большинстве случаев это не проблема, но в иногда такое может привести к неожиданному поведению, когда тест-кейсы будут мешать друг другу из-за загрязненной глобальной области видимости.test('It should make magic happen.', () => {\n  const wrapper = mount(SomeComponent);\n\n  // ...\n\n  expect(magicHappened).toBe(true);\n  // Vue 3.\n  wrapper.unmount();\n  // Vue 2.\n  wrapper.destroy();\n});Использование столь простого решения в тех редких случаях, когда это фактор, обычно нормально. Но люди могут запросто забыть об этом, поэтому я предпочитаю более общее решение.Я считаю лучшей практикой обертывание сторонних зависимостей, и @vue/test-utils не является исключением. Это позволяет нам установить параметры по умолчанию, которые целесообразно использовать для нашего приложения в глобальном масштабе.// Vue 3\n// test/utils.js\nimport { merge } from 'lodash';\nimport {\n  mount as vueTestUtilsMount,\n} from '@vue/test-utils';\n\nlet defaultOptions = {\n  global: {\n    mocks: {\n      // Mocked plugins\n      $t: input => input,\n    },\n  },\n  // ...\n};\n\nexport function mount(component, customOptions = {}) {\n  let options = merge({}, defaultOptions, customOptions);\n  return vueTestUtilsMount(component, options);\n}Более того, наличие кастомного модуля-обертки для @vue/test-utils дает нам идеальное место для настройки глобального поведения, подобного этому. К счастью, в @vue/test-utils для Vue 2 есть встроенная хелпер-функция, которая позволяет очень просто вызвать хук beforeDestroy для каждого компонента, инициализированного во время тестирования.// Vue 2\n// test/utils.js\nimport { merge } from 'lodash';\nimport {\n  mount as vueTestUtilsMount,\n  enableAutoDestroy,\n} from '@vue/test-utils';\n\n// See: https://vue-test-utils.vuejs.org/api/#enableautodestroy-hook\nenableAutoDestroy(afterEach);\n\nlet defaultOptions = {\n  mocks: {\n    // Mocked plugins\n    $t: input => input,\n  },\n  // ...\n};\n\nexport function mount(component, customOptions = {}) {\n  let options = merge({}, defaultOptions, customOptions);\n  return vueTestUtilsMount(component, options);\n}К сожалению, этот хук, похоже, был удален в @vue/test-utils для Vue 3. Поэтому нам нужно имплементировать данную функциональность самостоятельно.// Vue 3\n// test/utils.js\nimport { merge } from 'lodash';\nimport {\n  mount as vueTestUtilsMount,\n} from '@vue/test-utils';\n\nlet defaultOptions = {\n  global: {\n    mocks: {\n      // Mocked plugins\n      $t: input => input,\n    },\n  },\n  // ...\n};\n\nlet wrappers = new Set();\nafterEach(() => {\n  wrappers.forEach(wrapper => wrapper.unmount());\n  wrappers.clear();\n});\n\nexport function mount(component, customOptions = {}) {\n  let options = merge({}, defaultOptions, customOptions);\n  let wrapper = vueTestUtilsMount(component, options);\n  wrappers.add(wrapper);\n\n  return wrapper;\n}Подведение итоговТо, что сейчас переживает человечество в глобальном масштабе, справедливо и для программирования. Если устроить бардак, не взяв на себя ответственность за уборку после себя, это приведет к плохим последствиям.В любом приложении среднего размера разработчик сталкивается с задачей централизованного управления стейтом.В современном Vue 3 мы можем это делать и без Vuex, полагаясь только на hooks + provide/inject. Приглашаем на открытый урок «Сравнение стейт менеджеров — Redux vs Vuex vs новый — Pinua», на котором рассмотрим плюсы и минусы такого подхода в реальном приложении.Также в сообществе широко обсуждается упрощённый стейт-менеджер под названием Pinya. На занятии установим его и научимся пользоваться. Регистрация для всех желающих доступна по ссылке. "
]